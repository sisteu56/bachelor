%************************************************
\chapter{Commit-Feature Interactions}\label{ch:example_chapter}
%************************************************

In this section, we define structural and dataflow-based commit-feature interactions as well as properties related to them.
Furthermore, their meaning and relationship inside a software project is explained here. 
In the \nameref{ch:background} chapter, we discussed what purpose commits and features serve in a software project.
Commits are used to add new changes, whereas features are cohesive entities in a program implementing a specific functionality.
In this work, structural interactions are used to investigate how commits implement features and their functionality.
In addition, dataflow interactions are examined to gain additional knowledge on how new changes to a program, in the form of commits, affect features. 

\section{Structural CFIs}\label{sec:structural_cfis}

In the background chapter, we dicussed the concept of \nameref{ch:code_regions}, especially commit and feature regions. 
Logically, we speak of structural interactions between features and commits when their respective regions structurally interact. 
This structural interaction between code regions occurs when at least one instruction is part of both regions.
This is the case when code regions structurally interact through the \nameref{def:structural_relation} ($\circledcirc$).

\begin{definition}\label{def:structural_cfi}
\emph{A commit C with its commit regions $r_{1C}$, $r_{2C}$,... and a feature F with its feature regions $r_{1F}$, $r_{2F}$,... structurally interact, if at least one commit region $r_{iC}$ and one feature region $r_{jF}$ structurally interact with each other, i.e. $r_{iC}$ $\circledcirc$ $r_{jF}$.}
\end{definition}

Structural CFIs carry an important meaning, namely that the commit of the interaction was used to implement or change functionality of the feature of said interaction.
This can be seen when looking at an instruction accounting for a structural interaction, as it is both part of a commit as well as a feature region.
From the definition of \nameref{def:commit_regions}, it follows that the instruction stems from a source-code line that was last changed by the region's respective commit. 
From the definition of \nameref{def:feature_regions}, we also know that the instruction implements functionality of the feature region's respective feature. 
Thus, the commit of a structural interaction was used to extend or change the code implementing the feature of that interaction.
Following this, we can say that the commits, a feature structurally interacts with, implement the entire functionality of the feature.
That is because each source-code line of a git-repository was introduced by a commit and can only belong to a single commit.
Thus every instruction, including those part of feature regions, is annotated by exactly one commit region. 

Knowing the commits used to implement a feature allows us to determine the authors that developed it.
This is made possible by simply linking the commits, a feature structurally interacts with, to their respective authors.
By determining the authors of a feature, we can achieve a deeper insight into its development than solely focusing on the commits that implemented it. 

\section{Dataflow-based CFIs}\label{sec:dataflow_cfis}

Determining which commits affect a feature through dataflow can reveal additional interactions between commits and features that cannot be discovered with a structural analysis.
Especially dataflows that span over multiple files and many lines of code might be difficult for a programmer to be aware of.
Employing VaRA's dataflow analysis, that is dicussed in section~\ref{ch:implementation}, facilitates the detection of these dataflow interactions. \\
Commit interactions based on dataflow were explained in the \nameref{sec:interaction_analysis} section and can be considered as precursors to dataflow-based commit-feature interactions.
Similarly to commits interacting with other commits through dataflow, commits interact with features through dataflow, when there exists dataflow from a commit to a feature region.
This means that data allocared or changed within a commit region flows as input to an instruction located inside a feature region.
This pattern can also be matched to the \nameref{def:dataflow_relation} ($\rightsquigarrow$) when defining dataflow-based commit-feature interactions.

\begin{definition}\label{def:dataflow_cfi}
\emph{A commit C with its commit regions $r_{1C}$, $r_{2C}$,... and a feature F with its feature regions $r_{1F}$, $r_{2F}$,... interact through dataflow, if at least one commit region $r_{iC}$ interacts with a feature region $r_{jF}$ through dataflow, i.e. $r_{iC}$ $\rightsquigarrow$ $r_{jF}$.}
\end{definition}

\begin{lstlisting}[language=C++, caption={Illustration of structural and dataflow-based CFIs}, label=DescriptiveLabel]	
1. int calc(int val) {                             %\vartriangleright% %\texttt{d93df4a}%
2.    int ret = val + 5;                           %\vartriangleright% %\texttt{7edb283}%
3.    if (FeatureDouble) {                         %\vartriangleright% %\texttt{fc3a17d}%    %\vartriangleright% %FeatureDouble%
4.        ret = ret * 2;                           %\vartriangleright% %\texttt{fc3a17d}%    %\vartriangleright% %FeatureDouble%
5.    }                                            %\vartriangleright% %\texttt{fc3a17d}%    %\vartriangleright% %FeatureDouble%
6.    return ret;                                  %\vartriangleright% %\texttt{d93df4a}%   
7. }                                               %\vartriangleright% %\texttt{d93df4a}%   
\end{lstlisting}
\textsf{The above code snippet contains both structural as well as dataflow-based commit-feature interactions.
Commit \texttt{fc3a17d} implements the functionality of \texttt{FeatureDouble} for this function.
It follows that a structural commit-feature interaction can be found between them, as their respective commit and feature regions structurally interact.
Commit \texttt{7edb283} introduces the variable \texttt{ret} that is later used inside the feature region of \texttt{FeatureDouble}. 
This accounts for a commit-feature interaction through dataflow, as data that was produced within a commit region is used as input 
by an instruction belonging to a feature region of \texttt{FeatureDouble} later on in the program.}

\section{Combination of CFIs}\label{sec:combination_cfis}

When investigating dataflow-based CFIs, it is important to be aware of the fact that structural CFIs heavily coincide with them.
This means that whenever commits and features structurally interact, they are likely to interact through dataflow as well.
As our structural analysis has already discovered that these commits and features interact with each other, 
we are more interested in commit-feature interactions that can only be detected by a dataflow analysis.
That this relationship between structural and dataflow interactions exists becomes clear when looking at an instruction accounting for a structural CFI.
From definition~\ref{def:structural_cfi}, we know that the instruction belongs to a commit region of the interaction's respective commit.
It follows that data changed inside the instruction produces commit taints for instructions that use the data as input. 
Now, if instructions that use the data as input are also part of a feature region of the interaction's respective feature, the commit and feature of the structural interaction will also interact through dataflow.
However, such dataflow is very likely to occur, as features are functional units, whose instructions build and depend upon each other. 
Knowing this we can differentiate between dataflow-based CFIs that occur within the regions of a feature and those where data flows from outside the regions of a feature into them.
From prior explanations, it follows that this differentiation can be accomplished by simply checking whether a commit that influences a feature through dataflow, also structurally interacts with it. 

\section{Feature Size}\label{sec:feature_size}

When examining commit-feature interactions in a project, it is helpful to have a measure that can estimate the size of a feature.
We can use such a measure to compare features with each other and, thus, put the number of their interactions into perspective.
Considering our implementation, it makes most sense to define the size of a feature as the number of instructions implementing its functionality inside a program.
As the instructions inside the regions of a feature implement its functionality, we can the define the size of a feature as follows:
\begin{definition} \label{def:feature_size}
\emph{The} size \emph{of a feature is the number of instructions that are part of its feature regions.}
\end{definition}

\section{Feature-Related Concerns of a Commit}\label{sec:commit_concerns}

Often, multiple features are implemented in the same code space.
This can occur due to various reasons, for example being a sub-feature of an overarching feature or depending on data generated by other features.
Logically, the instructions stemming from the respective code are part of several feature regions.
At the same time, only a subset of these instructions actually implement functionality of a specific feature.
We say that these features are, at least partially, \texttt{nested} features.
If a developer introduces changes to such a nested feature, the according commit will also produce structural CFIs with other features.
Now, we are faced with the issue that, while the commit structurally interacts with several features, it only changes functionality of one.
In this case, it is impossible to tell which features the commit really changed from the raw data of its structural CFIs alone.
% We rather argue not about which features the commit affected specifically, but whether 
% We therefore examine in which code space the interactions occur and whether this code space belongs to the same set of features.
% As long as the commit only changed or added code within said code space with the same set of feature-regions 
Therefore, we say that the commit only deals with a single feature-related concern as long as the code its interactions stem from belong to the same set of features.
This code-property indicates that a single nested feature was changed by the commit instead of multiple features at once.
In our analysis, we are working with instructions and therefore speak of the same code space for features when the instructions we are dealing with belong to regions of the same features.
It follows that we can assign a commit a number of concerns according to its structural CFIs and the instructions they occur in:
\begin{definition} \label{def:commit_concerns}
\emph{The} feature-related concerns \emph{of a commit are the different sets of features the commit structurally interacts with at the same time, i.e. in the same instructions.}
\end{definition}
They should be used as a measure to gauge the responsibilities of a commit that are difficult to decipher due to feature-nesting. 
An examplatory use-case is shown in the listing below. \\
                             
\begin{lstlisting}[language=C++, caption={Example use-case for the feature-related concerns of a commit}]	
26. if (Min) {                             %\vartriangleright% %\texttt{b9ea2f3}%    %\vartriangleright% %Min%
27.    val = min(x,y)                      %\vartriangleright% %\texttt{b9ea2f3}%    %\vartriangleright% %Min%
28.    if (CheckZero) {                    %\vartriangleright% %\texttt{e37a1c8}%    %\vartriangleright% %Min% %\land% %CheckZero%
29.       if (val == 0) {                  %\vartriangleright% %\texttt{e37a1c8}%    %\vartriangleright% %Min% %\land% %CheckZero%
30.          throw Error();                %\vartriangleright% %\texttt{e37a1c8}%    %\vartriangleright% %Min% %\land% %CheckZero%
31.       }                                %\vartriangleright% %\texttt{e37a1c8}%    %\vartriangleright% %Min% %\land% %CheckZero%
32.    }                                   %\vartriangleright% %\texttt{e37a1c8}%    %\vartriangleright% %Min% %\land% %CheckZero%
33. }                                      %\vartriangleright% %\texttt{b9ea2f3}%    %\vartriangleright% %Min%
\end{lstlisting}
\label{lst:commit_concerns}
\textsf{The above code-snippet illustrates how considering the feature-related concerns of a commit is more insightful than simply looking at the features it structurally interacts with. \\ 
We can see that the commit \texttt{e37a1c8} exclusively implements functionality of the \texttt{CheckZero}-feature. 
Still, it also structurally interacts with the \texttt{Min}-feature, as the code of \texttt{CheckZero} is nested inside of it. 
However, commit \texttt{e37a1c8} only has a single feature-related concern, as it only affects source-code lines that encompass regions of the same set of features.
If commit \texttt{b9ea2f3} instead introduced the entire code-snippet, it would have two feature-related concerns.
In both cases, the feature-related concerns accurately reflect the number of features that were implemented by a commit.
At the same time, this is not true for the number of features a commit structurally interacts with.}

\section{Feature Nesting Degree}\label{sec:feature_nesting_degree}
As dicussed in section \ref{sec:commit_concerns}, feature-nesting is an important issue worth taking into account.
Instructions that are part of several feature regions will, by definition, also consitute the size of the respective features.
At the same time, it is unlikely that the instruction actually implements functionality for every one of them.
Thus, the size of a feature can encompass many instructions not implementing its functionality.
Technically, we can only be certain of an instruction's purpose if it is exclusively part of a single feature region.
In order to achieve a more accurate description of a feature's size, we introduce the concept of a feature's nesting degree:
\begin{definition} \label{def:feature_nesting_degree}
\emph{The} nesting degree \emph{of a feature is the fraction of its size where its respective regions do not appear exclusively.}
\end{definition}
Besides that, the nesting degree of a feature informs us about the frequency of feature-nesting within a feature and, in combination with other features, the entire project.

\section{Implementation}\label{ch:implementation}

The detection of structural as well as dataflow-based commit-feature interactions is implemented in VaRA \cite{VaRA2023}.
Additionaly to commit regions, VaRA maps information about its feature regions onto the compiler's IR during its construction.
Commit regions contain the hash and repository of their respective commits, whereas feature regions contain the name of the feature they originated from.
VaRA also gives us access to every llvm-IR instruction of a program and its attached information.
To accommodate later evaluations using nesting degrees, we create reports featuring a more complex datatype than a sole CFI.
For this, we specifically save which features a commit structurally interacts with at the same time, i.e. inside the same instructions.
We know that an instruction is always part of exactly one commit region, but could possibly belong to any number of feature regions.
According to definition~\ref{def:structural_cfi}, we encounter a structural CFI, if an instruction belongs to at least one feature region.
For every such instruction, we store the discussed interaction, as the commit and the features present in the instruction.
For each interaction, we also save the number of instructions it occurs in. 
This is accomplished by incrementing its instruction counter if we happen to encounter a duplicate. 
By creating complex structural reports, we can not only determine the nesting degree of each structural CFI later on, but also the nesting degrees of the instructions they occur in.
This allows us to calculate the definite size of a feature, additionally to its normal size defined in definition \ref{def:feature_size}.
We can compute the size of a feature as the sum over the instruction counters of all found interactions the feature is part of.
To calculate a feature's definite size, we only consider interactions where the feature appears exclusively.
These interactions stem from instructions with a nesting degree of one, which means that they are part of no further feature regions. \\
In the \nameref{sec:interaction_analysis} section, we discussed the taint analysis deployed by VaRA.
There, VaRA computes information about which code regions have affected an instruction through dataflow.
Checking whether a taint stems from a commit region allows us to extract information about which commits have tainted an instruction.
Thus, dataflow-based commit-feature interactions can also be collected on instruction level.
According to definition~\ref{def:dataflow_cfi}, we can store a dataflow-based interaction between a commit and a feature, if an instruction has a respective commit taint while belonging to a respective feature region.
Consequently said instruction uses data, that was changed by a commit region earlier in the program, as its input. 

\iffalse
For our research we examine numerous software projects to get a wide range of reference data, as commit-feature interactions could potentially vary greatly between different code spaces.
Accordingly, the VaRA-Tool-Suite was extended making it possible to generate a report comprising all found CFIs of an according type in a software project.
This aids us in examining several software projects to gain sufficient and sensible data about commit-feature interactions.
The created reports are also evaluated in the VaRA-Tool-Suite, which offers support to process and display statstics of the generated data. \\
\fi 
