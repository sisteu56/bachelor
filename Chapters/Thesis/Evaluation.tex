%************************************************
\chapter{Evaluation}\label{ch:evaluation}
%************************************************

This chapter evaluates the thesis core claims.
- for this, we investigate four projects

\section{Results}\label{sec:results}

\subsection*{\textbf{RQ1: Evaluation of Structural CFIs}}\label{sec:eval_struc_cfis}

\subsubsection*{Patterns of Feature Development}\label{sec:eval_feature_development}

Figure \ref{fig:feature_sfbr_plot} illustrates our results in three different plots for each project.
Each row displays the results for one project with the name of the respective project being shown on the far left. \\
In the first column, we show the number of structurally interacting commits for each feature in a bar-plot.
For all projects, we notice a wide distribution of structurally interacting commits between features.
Numerous features, across all projects, interact with less than 5 commits suggesting that they need very little work to be implemented.
On the other hand, both \textsc{xz} and \textsc{lrzip} have features structurally interacting with more than 20 commits, while \textsc{gzip} even has four features that interact with more than 60 commits.
With a mean of 29, the features of \textsc{gzip} have by far the highest number of interacting commits on average.
\textsc{xz}, \textsc{lrzip} and \textsc{bzip2} have much lower averages at 9, 16 and 4 respectively.
For the three lastly mentioned projects, most structural interactions occur at a nesting degree of one.
Still, some features are mostly or even entirely implemented by commits structurally interacting with them at a higher nesting degree.
This is true for almost all features of \textsc{gzip}, where only \textsf{recursive}, \textsf{test} and \textsf{verbose} are exceptions to the other 11 investigated features.
As all projects are of a compression domain, we can find several features with the same functionality across the examined projects.
The \textsf{verbosity}-feature structurally interacts with the most commits in \textsc{xz} and \textsc{bzip2}, while the same is not the case for the \textsf{verbose}-feature of \textsc{gzip}. 
Interestingly, most commits interact with them at a nesting degree of one, meaning that the commits were likely used to specifically change the respective features. 
Although \textsc{gzip} encompasses the highest average number of interacting commits, its \textsf{recursive}-feature only interacts with 2 commits, while the \textsf{recursive}-feature of \textsc{lrzip} interacts with 24 commits. \\
In the second column of figure \ref{fig:feature_sfbr_plot}, we display the calculated feature-sizes for each project.
Again, we see a large spread between the different feature-sizes within all projects.
Most notabely, there are large jumps between adjacent features, for example from \textsf{to\_stdout} with a size of 600 to \textsf{no\_name} with a size of 5500 in \textsc{gzip}.
Similarly to the number of interacting commits, \textsc{gzip} has by far the highest average feature size at 2500.
The average feature sizes for the other projects range from 190 for \testc{xz} to 390 for \textsc{bzip2}. 
The nesting of feature-code is most common in \textsc{gzip}, where the size of every feature completely or at least largely consists of potential feature size, i.e. instructions with a higher nesting degree than one.
Feature-nesting is least common in \textsc{xz} and \textsc{lrzip}, although features such as \textsf{Cores}, \textsf{ForceOverwrite} and \textsf{lrzcat} make for exceptions here. \\
Finally, the datasets used in the two previously dicussed plots are related inside the regression plot of figure \ref{fig:feature_sfbr_plot}.
For both \textsc{xz} and \textsc{gzip}, we determine a strong positive correlation between the size of a feature and its number of structurally interacting commits.
Their linear correlation coeffecients are close to 1 at 0.91 and 0.978 respectively with p-values smaller than $10^{-4}$.
This data provides strong evidence that our initial notion, that larger features generally need more commits to be implemented, is correct.
While \textsc{bzip2} and \textsc{lrzip} have positive correlation coefficients of 0.585 and 0.968 respectively, their p-vlaues are relatively high at over 0.1.
The high p-values can be explained by a lack of datapoints for \textsc{lrzip} and conflicting datapoints for \textsc{bzip2}.
For example, do both the \textsf{opMode}- and \textsf{srcMode}-feature of \textsc{bzip2} structurally interact with 6 commits, but encompass vastly different feature sizes.
Overall, the two projects do not produce conclusive statistical evidence that the size of a feature and the number of interacting commits is positively correlated.


\clearpage

\begin{figure}[htbp]
  \centering
  \includesvg[height=19cm]{gfx/results/RQ1/feature-sfbr-plot.svg}
  \caption{Feature Structural CFIs Plot}
  \label{fig:feature_sfbr_plot}
\end{figure}

\clearpage

\begin{figure}[htbp]
  \centering
  \includesvg[height=13cm]{gfx/results/RQ1/commit-sfbr-plot.svg}
  \caption{Commit Structural CFIs Plot}
  \label{fig:commit_sfbr_plot}
\end{figure}

\subsubsection*{Usage of Commits in Feature Development}\label{sec:eval_commit_usage}

When proposing RQ1, we derived a best practice of commits used in feature development, namely that they should mostly change a single feature.
We investigate to what extent this is enforced in our investigated software projects by examining the features a commit structurally interacts with, since these are the features a commit changes or implements.
The distribution of how many commits interact with a certain number of features is displayed in figure \ref{fig:commit_sfbr_plot}.
\textsc{xz} and \textsc{lrzip} have similar distributions, while the distributions of \textsc{gzip} and \textsc{bzip2} are rather unique.
For \textsc{xz} and \textsc{lrzip}, we note that the majority of commits structurally interact with a single feature.
The commit count gradually drops with an increasing number of structurally interacting features until it subsides to 0 at an x-value of 4.
\textsc{xz} encompasses two outlier commits that interact with more than 4 features. 
One of them imported the initial project to git and encompassed over 40000 additions.
The other commit had many different responsibilites changing 118 files and over 3000 lines of code.
Moving on to \textsc{gzip}, we notice a vastly different distribution compared to the previously discussed projects.
With a commit count of 48, the majority of commits structurally interact with 4 features, while only 8 commits interact with a single feature.
Interestingly, 47 out of the 48 commits interact with the exact same 4 features, namely \textsf{force}, \textsf{no\_name}, \textsf{method} and \textsf{decompress}.
Even though the commit count quickly falls after its peak at an x-value of 4, there still are many outlier commits interacting with 7 or more features.
For \textsc{bzip2}, there are much less commits used in feature-development with only 9 commits part of structural CFIs.
The distribution consists of two clusters, the first being at one interacting feature and the second being centered around six interacting features.
The second cluster encompassing 5 commits is slightly bigger than the first cluster with a commit count of 4.
Since we are only dealing with a few commits here, that still produce quite interesting and unique data, we have a closer look at the purpose of these commits and relate it with the number of features they structurally interact with.
We find that all commits part of the second cluster were used to publish new versions of \textsc{bzip2}, always encompassing over 1000 additions.
Three out of the four commits part of the first cluster introduced minor changes and bug fixes, never changing more than 30 source-code lines.
The remaining commit updated \textsc{bzip2} to version 1.0.4 fixing minor bugs from the previous version with many of the added source-code lines being used for comments. 

\begin{table}[t]
\caption{Additional Information for Structural Analysis of Commits}
\label{tab:commit_sfbr_table}
\begin{tabular}{lllll}
 Projects & Average & Only SCFI with ND1 & Filter Large Commits & Both Restrictions \\
  xz    & 1.47 & 1.23 & 1.3  & 1.11 \\
  gzip  & 4.31 & 1.13 & 4.08 & 1.03 \\
  bzip2 & 3.78 & 2.78 & 3.38 & 2.38 \\
  lrzip & 1.3  & 1.08 & 1.3  & 1.09 \\
\end{tabular}
\end{table}

To specify our initial observations, we show the average number of features a commit structurally interacts with in table \ref{tab:commit_sfbr_table}.
We apply two restrictions, where we exclude certain structural CFIs and commits, allowing us to form a lower bound for the number of features a commit usually changes.
Logically, we only consider commits with at least one interaction as we have done in figure \ref{fig:commit_sfbr_plot}.
The first column shows us that the averages for \textsc{xz} and \textsc{lrzip}, are slightly above 1 ranging from 1.3 to 1.47.
This is not the case for \textsc{gzip} and \textsc{bzip2} that have much higher averages at 4.31 and 3.78 respecitvely.
In the column to the right, we compute the same average, but filter structural CFIs with higher nesting degrees than one beforehand.
Across all projects, this ensures a decrease of the averages with the lowest value now being 1.08 for \textsc{lrzip} and the highest being 2.78 for \textsc{bzip2}.
The most notable decrease occurs for \textsc{gzip}, which is to be expected given its very high degree of feature-nesting seen in figure \ref{fig:feature_sfbr_plot}.
Here, it's important to clarify that we do not claim every CFI to be rightfully filtered or not filtered.
Following our explanations in section \ref{sec:nesting_degree}, we do expect to exclude numerous CFIs whose commits did not implement the interaction's feature specifically.
In a second restriction, we exclude commits we determined to be exceptionally large among the commits implementing features within their respective project.
Except for \textsc{lrzip}, this measure also ensures a slight, albeit less significant, decrease of the averages. 
We performed a qualitative analysis of the filtered commits to check whether our suspicion, that they were mostly used to refactor code, is true.
We find that many of them were used to import the project or newer versions to git.
The fact that such commits exist is unsurprising, considering that the investigated tools have been published before the release of git or before git was widespread.
While their purpose might not be refactoring code, it does make sense to filter these commits, as they are not accurately depicting the development process of the project itself or of its features.
Only two out of the eighteen commits we filtered in all projects, were actually used to refactor code, specifically moving contents between files or adapting the code to a newer version of C.
We admit that for half of all exceptionally large commits we found no reason, neither refactoring code or importing the project to git, to be left out of our analysis.
Finally, we apply both restrictions at the same time to form a lower bound for the number of features a commit usually changes.
Although \textsc{gzip} had the highest initial average, its average is the lowest at 1.05 after the application of our two restrictions.
For \textsc{xz}, \textsc{gzip} and \textsc{lrzip} the final average falls below 1.1, which is certainly closer to 1 than the general average.

\subsection*{\textbf{RQ2: Evaluation of Dataflow-based CFIs}}\label{sec:eval_df_cfis}

\subsubsection*{Proportion and Dependencies of Commits Affecting Features through Dataflow}\label{sec:eval_commit_dfbr}

The initial step in evaluating what fraction of commits affect features through dataflow, is determing the number of active commits.
Active commits are represented by at least one commit region inside a program, meaning that they fullfil the minimum requirement to be part of a dataflow-based CFI.
The respective values are shown in the first column of table \ref{tab:commit_dfbr_table} for each project.
We determined \textsc{xz} to have the highest number of active commits at 1039, while \textsc{bzip2} only has a tiny fraction of that at 37.
In the first plot of figure \ref{fig:commit_dfbr_plot}, the bars colored in red show what percenateg of commits interact with features through dataflow.
We notice that the respective percentages are vastly different from project to project.
The majority of \textsc{gzip}'s active commits are part of dataflow-based CFIs at 53.6\%.
This percentage gets halved for \textsc{bzip2} with about 27\%, with another large drop to 11.3\% for \textsc{xz}.
This means that roughly every second commit in \textsc{gzip}, every fourth commit in \textsc{bzip2} and every ninth commit in \textsc{xz} affects features through dataflow.
The bars colored in grey display the fraction of active commits structurally interacting with features.
In addition to the obvious fact of how often commits are used to implement features, this also gives us an estimation on the extend of feature-code in a project.
The more commits are part of structural CFIs, the more of the code contributed by them and therefore the overall code of a project will be part of feature regions.
Logically, the accuracy of this estimation depends on many factors, such as the extend to which commits contributing code to features, also contribute code to other parts of a program.
Still, given the large disparity in the percentage of commits with structural interactions, we can be relatively certain that \textsc{xz} has the lowest proportion and \textsc{gzip} the largest proportion of feature-code with \textsc{bzip2} somewhere inbetween.
Comparing the two bar-types, we notice that the percentage of commits with structural interactions is lower than the percentage of commits with dataflow interactions for each project.

\begin{table}[t]
\caption{Additional Information for Dataflow Analysis of Commits}
\label{tab:commit_dfbr_table}
\begin{tabular}{lll}
 Projects & Number of Active Commits & Probability for Commit to be part of dataflow CFI \\
 	  & 			     & given that it is part of structural CFI \\
xz & 1039 & 0.883 \\
gzip & 194 & 0.933 \\
bzip2 & 37 & 0.889 \\
\end{tabular}
\end{table}

This phenomenon can be explained considering the values presented in the second column of table \ref{tab:commit_dfbr_table}.
There, we show the probablity for a commit to be part on any dataflow-based CFI, given that said commit is part of any structural CFI.
We see that the probabilities are roughly the same for each project at around 90\%.
This means that by only taking into account commits part of structural CFIs, we already encounter a lot of commits that affect features through dataflow.
If we then consider the entire set of active commits, the number of commits with dataflow interactions will likely exceed the number of commits with structural interactions.
Across all projects, the probability of a commit interacting with features through dataflow, given that it is part of structural CFIs, is much higher than the same probability for any active commit.
This is a clear indication that our assumptions in section \ref{sec:combination_cfis}, that structural CFIs heavily coincide with dataflow-based CFIs, are correct.
Since our intent is to especially focus on commits whose interactions with features can only be discovered by employing our dataflow analysis, we now aim to quantify these commits in the investigated projects.
For this, we examine the relative difference between the percentages of commits with structural and commits with dataflow interactions.
This difference roughly determines what share of commits are part of the discussed more interesting dataflow interactions.
The difference is the smallest for \textsc{bzip2} at 10\% and slightly higher than that for \textsc{gzip} at 15\%.
\textsc{xz} has by far the biggest relative difference at almost 49\%, which means that our dataflow analysis reveals many additional interactions here.
We explore the topic of different dataflow interaction types more thoroughly in our second plot, which focuses on the \textsf{origin} of dataflow. \\
There, we have a closer look at the commits affecting features through dataflow and where their dataflow stems from.
Naturally, dataflow occuring inside the regions of a feature is more intentional and therefore less interesting, than dataflow originating outside its regions.
In section \ref{sec:combination_cfis}, we explain, that the dataflow of commits and features not structurally interacting with each other, must be outside dataflow.
Even though the regions of a commit and regions of a feature must partially overlap in order for them to structurally interact, such a commit can still have regions not part of any feature regions.
Therefore, we cannot be sure whether the dataflow of these interactions originates from outside or inside the regions of a feature.
Due to the inherent properties of structural interactions, i.e. heavily coinciding with dataflow interactions, we assume their dataflow to originate inside the regions of a feature.
In the second plot of figure \ref{fig:commit_dfbr_plot}, we separate the commits with dataflow interactions into three categories based on dataflow origin.
The first category, shown as the bar colored in blue, represents commits that only interact with features through outside dataflow.
They make up the majority of commits for \textsc{xz} at 56.4\% and only 20\% of commits for both \textsc{bzip2} and \textsc{gzip}.
The second category represents commits that interact with features through outside and inside dataflow.
Logically, these commits affect at least two features through dataflow and only structurally interact with a subset of them.
Surprsingly, they form the majority of commits for \textsc{bzip2} and \textsc{gzip} at 60 and 51\% respectively and around 20\% of commits for \textsc{xz}.
The proportion of commits that only interact with features through inside dataflow varies less between the projects.
\textsc{gzip} has the highest percentage at 28.8\%, \textsc{bzip2} the lowest at 20\% with \textsc{xz} inbetween the two at 23.9\%. \\
We admit that the high proportions of commits with both inside and outside dataflow are rather unexpected.
They hinder a clear separation of commits with dataflow interactions into less and more interesting commits, e.g. commits whose dataflow interactions are more and less obvious.
We notice that commits interacting with features through inside dataflow, have a high chance to also interact with other features through outside dataflow.
By definition, all commits interacting with features through inside dataflow also structurally intercact with them.
From previous explanations, we also know these commits are almost identical to the entire set of commits with structural interactions.
It follows that commits part of structural CFIs must also have a high, albeit slightly lower, chance to affect features through outside dataflow.
We compare this probability to the probability of any active commit to interact with features through outside df in table \ref{tab:commit_dfbr_rel_table}.
The strongest contrast occurs for \textsc{xz}, where 41.7\% of commits structurally interacting with features, interact with other features through outside df, making them 4.8 times more likely to do so compared to any active commit of \textsc{xz} at 8.6\%.
The contrast is slightly weaker for \textsc{bzip2} with a 3.1 times higher likelihood and according percentages of 66.7 and 21.6\% respectively. 
\text{gzip} has the weakest contrast at 1.58 and respective probabilites of 59.6 and 38.1\%. 

\begin{figure}[htbp]
  \centering
  \includesvg[height=9cm]{gfx/results/RQ2/proportional_commit_dfbr_plot.svg}
  \caption{Proportional Dataflow-Plot for Commits}
  \label{fig:commit_dfbr_plot}
\end{figure}

\begin{table}[t]
\caption{Relating Inside Dataflow to Outside Dataflow}
\label{tab:commit_dfbr_rel_table}
\begin{tabular}{lll}
 Projects & Probability for Commits Part of Structural CFIs & Same Probability Given 	\\
 	  & to Affect other Features Through Outside DF     & Any Active Commit		\\
xz & 0.417 & 0.086 \\
gzip & 0.596 & 0.381 \\
bzip2 & 0.667 & 0.216 \\
\end{tabular}
\end{table}

\clearpage

\begin{figure}[htbp]
  \centering
  \includesvg[height=19cm]{gfx/results/RQ2/feature_dfbr_plot.svg}
  \caption{Proportional Dataflow-Plot for Features}
  \label{fig:feature_dfbr_plot}
\end{figure}

\clearpage

\subsubsection*{Understanding Features and the Commits Affecting them Through Dataflow}\label{sec:eval_feature_dfbr}

\subsection*{\textbf{RQ3: Evaluation of Author Interactions}}\label{sec:eval_author_interactions}

- the project \textsc{xz} has mostly been developed by a single author, which is reflected in our results \\
- as can be seen in figure \ref{fig:author_cfi_plot}, all except one feature have exclusively been implemented by the same author \\
- we can conclude that it also is the developer affecting features through outside dataflow, since no feature has unique dataflow authors \\
- it follows that the linear regression relating the size of a feature to the number of its interacting authors shows no significant correlation \\

- \textsc{bzip2} inconclusive data, no correlation to be found \\
- \textsc{lrzip} more authors of features, but no general trend to be found due to lack of features \\

- \textsc{gzip}, on the other hand, provides us with much more comprehensive results \\
- it can immediately be seen that every feature has a large number of interacting authors \\
- the overall number of authors that interact with a feature in any way can be computed by the sum of its structural and its unique dataflow authors \\
- this means that the lowest number of interacting authors is 7 for the \textsf{recursive}-feature and the highest number 14 for the \textsf{force}-feature \\
- on average, a feature has more dataflow than structural authors with respective averages of 9.1 and 5.7 \\
- the average number of unique dataflow authors is 5.9, which means that our dataflow analysis discovers many additional interacting authors in \textsc{gzip} \\
- the number of structurally interacting authors, i.e. authors implementing a feature, range from 2 to 13 between the features of \textsc{gzip} \\
- there is less variance in the number of a feature's outside dataflow authors ranging from 7 to 12 \\
- features with relatively few structural authors, have a comparatively high number of dataflow authors \\
- features with many structural authors, starting from the \textsc{no\_name}-feature, have less outside dataflow authors \\ 
- at the same time, the number of their unique dataflow authors is rather low, implying that most of them also structurally interact with the according features \\
- the fact that the group of features with few structural authors has much more dataflow authors conditions them to have many unique dataflow authors \\
- still, more than 80\% of their structural authors also interact with them through outside dataflow \\
- the same cannot be said for the group of features with many structural authors, where this is the case for less than 45\% of them \\
- overall, there is a 57\% likelihood for the structural author of any feature to also interact with the feature through outside dataflow \\
- similarly to the bar-plot of \textsc{gzip}, we notice two clusters when examining its regression plots in figure \ref{fig:author_cfi_plot} \\
- the first cluster is made up of features with few structural authors, whose respective sizes range between 50 and 500 \\
- the second cluster consists of the four features who all have over 10 structural authors and feature-sizes ranging from 5500 to 6500 \\
- it is unsurprising that we compute a strong positive correlation between the size of a feature and its structurally interacting developers \\
- the respective correlation coefficient is 0.976, while the p-value is smaller than $10^{-4}$ \\
- regarding the dataflow authors of features, we note two similar clusters that consist of the same features of smaller and large sizes respectively \\
- now, the smaller features have slightly more dataflow authors centering around 10 than the much larger features with an average of 8 \\
- this shows itself in a negative correlation coefficient of -0.746 and a p-value of 0.003 falling out of our rejection range \\
- 
































\begin{figure}[htbp]
  \centering
  \includesvg[height=19cm]{gfx/results/RQ3/author-cfi-plot.svg}
  \caption{Author CFI Plot}
  \label{fig:author_cfi_plot}
\end{figure}

\clearpage 

\section{Discussion}\label{sec:discussion}

\subsection*{\textbf{RQ1: Structural CFIs}}\label{sec:eval_struc_cfis}

\textsc{bzip2} has shown to be a project whose results need to be treated carefully.
Only 9 commits structurally interact with its features, encompassing much less datapoints compared to the other investigated projects.
6 out of 9 commits were used to import the initial project to git and iteratively update the code to newer versions.
These commits are not exemplary of the common development process of a project and its features in a git repository.
The actual development of the tool in the git repository began after \textsc{bzip2} was finally updated to version 1.0.6.
The remaining 3 commits introduce minor changes and small bug fixes to the respective features they interact with.
This means that \textsc{bzip2}'s features were largely implemented already when the actual development within the repository started.
Thus, the number of features a commit changes on average as well as the commits structurally interacting with features are not good representatives of other projects developed in git. \\
When evaluating feature sizes, we noticed that, especially in the case of \textsc{gzip}, feature-nesting is more common than initially expected.
Most of the computed size of the respective features is made up of instructions that are part of multiple feature-regions besides its own.
This makes it difficult to clearly interpret the data, as the number of instructions that actually implement a feature can differ greatly from our observed size.
This phenonemon also bears consequences on they way commits are used in feature development and the CFIs resulting from this.
If a developer wants to specifically change a feature nested inside other features, the according commit will necessarily produce structural CFIs with several features.
In this context, it might be worth investigating whether such a nested feature implements separate, combined or additional functionality from the features it is nested inside.
This could help us decide whether a respective structural CFI implies that the commit actually implemented functionality of the feature.
At least for partially nested features, we have shown a method that can help us better predict the purpose of a commit structurally interacting with it.
If the commit also changes instructions that exclusively belong to a respective region of the feature, the according structural CFI will have a nesting degree of one.
With this, we can now predict that the commit was used to specifically change the feature with more definity.
The fact that this method has some impact on our generated data can especially seen for features encompassing some potential feature size, but no commits interacting with it at nesting degree higher than one.\\
We employed the pearson correlation coefficient to investigate the linear relationship between the size of a feature and the number of commits structurally interacting with it.
While we found high correlation coefficients of 0.9 and above, the p-values were often not low enough to justify the data to be statistically significant.
We know that p-values are highly dependent on the number of datapoints, whereas the datapoints of our linear regression are the respective features of a project.
Logically, projects with fewer features have less datapoints resulting in their p-values being quite high and falling into our rejection interval.
With 10 and 14 features respectively, \textsc{xz} and \textsc{gzip} have by far the most datapoints and according p-values of $>10^{-4}$ giving us most significant evidence for a strong positive correlation. 
Therefore, future research should prefer projects with at least 10 features so that correlations and other measurments produce trustful statistical data. 
Another possibility to circumvent the problem of too few datapoints could be to combine features of all projects into one big dataset.
Here, we are faced with the issue that the way commits are used among projects might differ drastically. 
In our case, the number of instructions per structurally interacting commit of a feature varies greatly from project to project.
The respective values are 17 for \textsc{xz}, 48 for \textsc{gzip}, 87 for \textsc{bzip2} and 13 for \textsc{lrzip}.
This means that features of a similar size have vastly different numbers of structurally interacting commits on average.
Upon these considerations, we are of the opinion that it makes more sense to test correlations within projects as we have done in this work.\\
We have already alluded that the 3-4 times higher general average of \textsc{gzip} compared to \textsc{xz} and \textsc{lrzip} stems from its extremely high degree of feature-nesting.
Even the large features, \textsf{force}, \textsf{no\_name}, \textsf{method} and \textsf{decompress} are mostly nested inside each other.
These are also the features all commits, constituting the peak of \textsc{gzip}'s distribution in figure \ref{fig:commits_sfbr_plot}, interact with. 
The fact that features are implemented in the same code-space makes the discussed distribution rather arbitrary.
This supports the notion, that we should rather investigate projects with little feature-nesting to answer our research question of how many features a commit usually changes.
In projects with a lesser degree of feature-nesting, the code of different features is located in separate parts of a program.
If a commit structurally interacts with several features there, we can be more certain that it was really supposed to change or implement multiple features. \\
When determining a lower bound for the number of features a commit usually changes, we filtered structural CFIs with a higher nesting degree than one.
Performing a qualitative analysis of the filtered CFIs could tell us whether this measure is justified.
For this, one would have to check whether the commit was really not used to implement or change functionality of the interaction's feature.
Our qualitive analysis of the excluded expectionally large commits has shown that while many commits were rightfully disregarded, there were still some for which this wasn't the case.
However, performing the same verification is definitely more challenging for structural CFIs.
Firstly, we are dealing with more than twice as many filtered structural CFIs than excluded commits.
Secondly, the decision to exclude a commit can mostly be based of its commit message, as it already tells us its general purpose.
The same cannot be done for a structural CFI, since it is plausible that the changed feature is not explicitly mentioned in the commit message.
We would rather have to look into the changed source-code lines and decide whether the commit implemented the feature based on that.
Without a thourough knowledge of the project and its respective features, this will take much longer to accomplish and will be error-prone as well.
We therefore refrain from carrying out such an analysis of the filtered structural CFIs in this work. \\

\iffalse In the previous section, we mentioned that the number of instructions per interacting commit of a feature varies between projects.
Since instructions stem from source-code lines, their respective amount can in turn indicate the number of lines they stem from.
Thus, we can derive that the lines of code a commit usually changes or contributes to a feature likely differs between projects as well.
Disregarding \textsc{bzip2}, the number of instructions per commit range from 13 to 48.
Given that a single source-code line generally produces several llvm-IR instructions, we can predict the number of lines per commit to be below 10.
This is a surprsingly low amount indicating that a commit often only introduces small changes to a feature.
Of course, this is just a rough, and perhaps inaccurate, prediction, but it shows that our generated data can be used for many applications. \fi

\section{Threats to Validity}\label{sec:threats}

In this section, discuss the threats to internal and external validity.

