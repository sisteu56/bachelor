%************************************************
\chapter{Evaluation}\label{ch:evaluation}
%************************************************

This chapter evaluates the thesis core claims.
- for this, we investigate four projects

\section{Results}\label{sec:results}

\subsection*{\textbf{RQ1: Evaluation of Structural CFIs}}\label{sec:eval_struc_cfis}

\subsubsection*{Patterns of Feature Development}\label{sec:eval_feature_development}

Aside from the number of commits used during its development, we can also extract the size of a feature from its structural CFIs.
These are the main properties we consider when investigating patterns around feature development.
Additionally, we factor in the nesting degree of structural CFIs during our analysis allowing us to extract more information from both properties.
Figure \ref{fig:feature_sfbr_plot} illustrates our results in three different plots for each project.
Each row displays the results for one project with the name of the respective project being shown on the far left. \\
In the first column, we show the number of structurally interacting commits for each feature in a bar-plot.
We differentiate between interactions with a nesting degree of 1, which are colored in blue, and ones with a higher nesting degree colored in orange.
The orange bar represents commits for which we are less certain of their specific purpose, where they could have been used to implement its respective feature and others at the same time. 
Overall, we notice a large spread of structurally interacting commits between features across all projects.
Most interactions occur at a nesting degree of 1, especially for features with many interacting commits in comparison to other features of their respective project.
Interestingly, for features with few interacting commits, a large proportion of their interactions have a higher nesting degree than 1.
We also notice that the range of interacting commits varies greatly between the different projects.
In \textsc{bzip2}, the highest number of interacting commits is 7 for the \textsc{verbosity} feature, but at over 60 for the \textsc{force,no\_name} feature in \textsc{gzip}.
The lowest number of interacting commits is 1 for all projects, except lrzip with 6, indicating that some features need very little work to be implemented.
The projects \textsc{xz} and \textsc{bzip2} bear some similarities, such as the \textsc{Verbosity}-feature having the highest number of interacting commits.
Both \textsc{xz} and \textsc{bzip2} also share a \textsc{ForceOverwrite}-feature, which has an average number of interacting commits in both projects, with a large portion of interactions having a nesting degree higher than one. \\
In the second column, we display the different feature sizes for each project in a bar-plot.
There is a wide distribution of their respective sizes among the features of a project.
Many consist of close to 0 and up to 150 instructions, which only is a small fraction of the size of the largest features.
Upon examining the shown feature sizes, we notice a pattern similar to that of the first column.
Here, larger features mostly consist of definite feature size, whereas smaller features have a high proportion of potential feature size.
This is not the case for \textsc{bzip2}, where all features have a high amount of potentially implementing instructions.
Surprisingly, this is also true for features that only have commits structurally interacting with them at nesting degree one.
The largest combined feature size we encounter is above 5000 for the feature \textsc{force,no\_name}, which is also the feature with most interacting commits.
For the projects \textsc{xz}, \textsc{bzip2} and \textsc{lrzip} the average feature size ranges between 200 and 400, while \textsc{gzip} has an average ofOnly  around 1.200.
This is the due to the very large feature we mentioned, which encompasses 4000 more instructions than the second largest feature. \\
In the third column of figure \ref{fig:feature_sfbr_plot}, the datasets used in the two previously dicussed plots are related inside two regression plots.
Broadly speaking, we plot the size of a feature against the number of commits that structurally interact with it.
For the regression plot colored in blue, we only consider the definite size of a feature and commits structurally interacting with them at a nesting degree of one.
The values of the displayed scatter points are identical with the values of the blue bars in the two previous columns. 
In the second regression plot, we consider all structurally interacting commits and all instructions regardless of any nesting degree.
As we now factor in the combined values of the blue and orange bars of the previous columns, the color of the plot is a combination of the two.
The respective correlation coefficents and p-values are shown at the bottom-right of each graph.
They are calculated with the pearson correlation coefficent, which measures the linear relationship between two datasets.
Across all projects and both linear regressions, we note a positive correlation between the size of a feature and the number of structurally interacting commits.
For both linear regressions, the correlation coefficients are quite high, ranging from ca. 0.9 for \textsc{xz} to ca. 0.98 for \textsc{lrzip}.
\textsc{bzip2} makes for the only exception here, where the correlation coefficent rises from 0.59 for the broader to 0.89 for the more specific consideration.
The p-values of \textsc{xz}, \textsc{gzip2} and the more restrictive dataset of \textsc{bzip2} are all lower than 0.025.
Thus, they lay outside of our rejection interval of 95\% indicating a high probality that both datasets are not un-correlated.
Combined with the high correlation coefficients, this gives us high confidence that the size of a feature and the number of commits used during its development are strongly positively correlated.
The fact that \textsc{lrzip} only has three datapoints, means that the p-values of their correlation coefficient are also relatively high at over 0.1.
The broader consideration of \textsc{bzip2} also encompasses values that do not produce enough statistical evidence to support the notion that the two related datasets are correlated.

\clearpage

\begin{figure}[htbp]
  \centering
  \includesvg[height=19cm]{gfx/results/RQ1/feature-sfbr-plot.svg}
  \caption{Feature Structural CFIs Plot}
  \label{fig:feature_sfbr_plot}
\end{figure}

\clearpage

\begin{figure}[htbp]
  \centering
  \includesvg[height=13cm]{gfx/results/RQ1/commit-sfbr-plot.svg}
  \caption{Commit Structural CFIs Plot}
  \label{fig:commit_sfbr_plot}
\end{figure}

\subsubsection*{Usage of Commits in Feature Development}\label{sec:eval_commit_usage}

When proposing RQ1, we derived a best practice of commits used in feature development, namely that they should mostly change a single feature.
We investigate to what extent this is enforced in our investigated software projects by examining the features a commit structurally interacts with, since these are the features a commit changes or implements.
The distribution of how many commits interact with a certain number of features is displayed in figure \ref{fig:commit_sfbr_plot}.
\textsc{xz}, \textsc{gzip} and \textsc{lrzip} have similar distributions, which is why we discuss them now and \textsc{bzip2} later.
For \textsc{xz}, \textsc{gzip} and \textsc{lrzip}, we note that the majority of commits structurally interact with a single feature.
\textsc{gzip} has the strongest contrast, with over 70 commits interacting with only one feature and just 13 commits interacting with multiple features.
Among the three mentioned projects, \textsc{xz} has the weakest contrast with around one third of commits interacting with more than one feature.
The commit count gradually drops with an increasing number of structurally interacting features until it subsides to 0 at an x-value of 4.
Both \textsc{xz} and \textsc{gzip} have some outlier commits interacting 5 and 6 features.
Surprisingly, the outlier commit \textsf{30ba4a2b} of \textsc{gzip} only changes 47 source-code lines being used to fix "theoretical races in signal handling".
One outlier commits of \textsc{xz} imported the initial project to git and encompassed over 40000 additions.
The other commit had many different responsibilites changing 118 files and over 3000 lines of code.
Moving on to \textsc{bzip2}, we notice a vastly different distribution compared to the previously discussed projects
Overall there are much less commits used in feature-development with only 9 commits part of structural CFIs.
The distribution consists of two clusters, the first being at one interacting feature and the second being centered around six interacting features.
The second cluster encompassing 5 commits is slightly bigger than the first cluster with a commit count of 4.
Since we are only dealing with a few commits here, that still produce quite interesting and unique data, we have a closer look at the purpose of these commits and relate it with the number of features they structurally interact with.
We find that all commits part of the second cluster were used to publish new versions of \textsc{bzip2}, always encompassing over 1000 additions.
Three out of the four commits part of the first cluster introduced minor changes and bug fixes, never changing more than 30 source-code lines.
The remaining commit updated \textsc{bzip2} to version 1.0.4 fixing minor bugs from the previous version with many of the added source-code lines being used for comments. 

\begin{table}[t]
\caption{Additional Information for Structural Analysis of Commits}
\label{tab:commit_sfbr_table}
\begin{tabular}{lllll}
 Projects & Average & Only SCFI with ND1 & Filter Large Commits & Both Restrictions \\
  xz    & 1.47 & 1.23 & 1.3  & 1.11 \\
  gzip  & 1.2  & 1.14 & 1.18 & 1.1 \\
  bzip2 & 3.78 & 2.78 & 3.38 & 2.38 \\
  lrzip & 1.3  & 1.08 & 1.3  & 1.09 \\
\end{tabular}
\end{table}

To specify our initial observations, we show the average number of features a commit structurally interacts with in table \ref{tab:commit_sfbr_table}.
We apply two restrictions, where we exclude certain structural CFIs and commits, allowing us to form a lower bound for the number of features a commit usually changes.
Logically, we only consider commits with at least one interaction as we have done in figure \ref{fig:commit_sfbr_plot}.
The first column shows us that the averages for \textsc{xz}, \textsc{gzip} and \textsc{lrzip}, are slightly above 1 ranging from 1.2 to 1.47.
The average for \textsc{bzip2} represents the only outlier at 3.78, which is to be expected given its discussed distribution.
In the column to the right, we compute the same average, but filter structural CFIs with higher nesting degrees than one beforehand.
Across all projects, this ensures a decrease of the averages with the lowest value now being 1.08 for \textsc{lrzip} and the highest being 2.78 for \textsc{bzip2}.
Here, it's important to clarify that we do not claim every CFI to be rightfully filtered or not filtered.
Following our explanations in section \ref{sec:nesting_degree}, we do expect to exclude numerous CFIs whose commits did not implement the interaction's feature specifically.
In a second restriction, we exclude commits we determined to be exceptionally large among the commits implementing features within their respective project.
Except for \textsc{lrzip}, this measure also ensures a slight, albeit less significant, decrease of the averages. 
We performed a qualitative analysis of the filtered commits to check whether our suspicion, that they were mostly used to refactor code, is true.
We find that many of them were used to import the project or newer versions to git.
The fact that such commits exist is unsurprising, considering that the investigated tools have been published before the release of git or before git was widespread.
While their purpose might not be refactoring code, it does make sense to filter these commits, as they are not accurately depicting the development process of the project itself or of its features.
Only two out of the eighteen commits we filtered in all projects, were actually used to refactor code, specifically moving contents between files or adapting the code to a newer version of C.
We admit that for half of all exceptionally large commits we found no reason, neither refactoring code or importing the project to git, to be left out of our analysis.
Finally, we apply both restrictions at the same time to form a lower bound for the number of features a commit usually changes.
For \textsc{xz}, \textsc{gzip} and \textsc{lrzip} this final average centers around 1.1, which is certainly closer to 1 than the general average.
\textsc{bzip2} still has the highest average at 2.38, although we note the biggest decrease for it from an initial value of 3.78. 

\subsection*{\textbf{RQ2: Evaluation of Dataflow-based CFIs}}\label{sec:eval_df_cfis}

\subsubsection*{Proportion and Dependencies of Commits Affecting Features through Dataflow}\label{sec:eval_commit_dfbr}

The initial step in evaluating what fraction of commits affect features through dataflow, is determing the number of active commits.
Active commits are represented by at least one commit region inside a program, meaning that they fullfil the minimum requirement to be part of a dataflow-based CFI.
The respective values are shown in the first column of table \ref{tab:commit_dfbr_table} for each project.
We determined \textsc{xz} to have the highest number of active commits at 1039, while \textsc{bzip2} only has a tiny fraction of that at 37.
In the first plot of figure \ref{fig:commit_dfbr_plot}, the bars colored in red show what percenateg of commits interact with features through dataflow.
We notice that the respective percentages are vastly different from project to project.
The majority of \textsc{gzip}'s active commits are part of dataflow-based CFIs at 53.6\%.
This percentage gets halved for \textsc{bzip2} with about 27\%, with another large drop to 11.3\% for \textsc{xz}.
This means that roughly every second commit in \textsc{gzip}, every fourth commit in \textsc{bzip2} and every ninth commit in \textsc{xz} affects features through dataflow.
The bars colored in grey display the fraction of active commits structurally interacting with features.
In addition to the obvious fact of how often commits are used to implement features, this also gives us an estimation on the extend of feature-code in a project.
The more commits are part of structural CFIs, the more of the code contributed by them and therefore the overall code of a project will be part of feature regions.
Logically, the accuracy of this estimation depends on many factors, such as the extend to which commits contributing code to features, also contribute code to other parts of a program.
Still, given the large disparity in the percentage of commits with structural interactions, we can be relatively certain that \textsc{xz} has the lowest proportion and \textsc{gzip} the largest proportion of feature-code with \textsc{bzip2} somewhere inbetween.
Comparing the two bar-types, we notice that the percentage of commits with structural interactions is lower than the percentage of commits with dataflow interactions for each project.
This phenomenon can be explained considering the values presented in the second column of table \ref{tab:commit_dfbr_table}.
There, we show the probablity for a commit to be part on any dataflow-based CFI, given that said commit is part of any structural CFI.
We see that the probabilities are roughly the same for each project at around 90\%.
This means that by only taking into account commits part of structural CFIs, we already encounter a lot of commits that affect features through dataflow.
If we then consider the entire set of active commits, the number of commits with dataflow interactions will likely exceed the number of commits with structural interactions.
Across all projects, the probability of a commit interacting with features through dataflow, given that it is part of structural CFIs, is much higher than the same probability for any active commit.
This is a clear indication that our assumptions in section \ref{sec:combination_cfis}, that structural CFIs heavily coincide with dataflow-based CFIs, are correct.
Since our intent is to especially focus on commits whose interactions with features can only be discovered by employing our dataflow analysis, we now aim to quantify these commits in the investigated projects.
For this, we examine the relative difference between the percentages of commits with structural and commits with dataflow interactions.
This difference roughly determines what share of commits are part of the discussed more interesting dataflow interactions.
The difference is the smallest for \textsc{bzip2} at 10\% and slightly higher than that for \textsc{gzip} at 15\%.
\textsc{xz} has by far the biggest relative difference at almost 49\%, which means that our dataflow analysis reveals many additional interactions here.
We explore the topic of different dataflow interaction types more thoroughly in our second plot, which focuses on the \textsf{origin} of dataflow. \\
There, we have a closer look at the commits affecting features through dataflow and where their dataflow stems from.
Naturally, dataflow occuring inside the regions of a feature is more intentional and therefore less interesting, than dataflow originating outside its regions.
In section \ref{sec:combination_cfis}, we explain, that the dataflow of commits and features not structurally interacting with each other, must be outside dataflow.
Even though the regions of a commit and regions of a feature must partially overlap in order for them to structurally interact, such a commit can still have regions not part of any feature regions.
Therefore, we cannot be sure whether the dataflow of these interactions originates from outside or inside the regions of a feature.
Due to the inherent properties of structural interactions, i.e. heavily coinciding with dataflow interactions, we assume their dataflow to originate inside the regions of a feature.
In the second plot of figure \ref{fig:commit_dfbr_plot}, we separate the commits with dataflow interactions into three categories based on dataflow origin.
The first category, shown as the bar colored in blue, represents commits that only interact with features through outside dataflow.
They make up the majority of commits for \textsc{xz} at 56.4\% and only 20\% of commits for both \textsc{bzip2} and \textsc{gzip}.
The second category represents commits that interact with features through outside and inside dataflow.
Logically, these commits affect at least two features through dataflow and only structurally interact with a subset of them.
Surprsingly, they form the majority of commits for \textsc{bzip2} and \textsc{gzip} at 60 and 51\% respectively and around 20\% of commits for \textsc{xz}.
The proportion of commits that only interact with features through inside dataflow varies less between the projects.
\textsc{gzip} has the highest percentage at 28.8\%, \textsc{bzip2} the lowest at 20\% with \textsc{xz} inbetween the two at 23.9\%. \\
We admit that the high proportions of commits with both inside and outside dataflow are rather unexpected.
They hinder a clear separation of commits with dataflow interactions into less and more interesting commits, e.g. commits whose dataflow interactions are more and less obvious.
We notice that commits interacting with features through inside dataflow, have a high chance to also interact with other features through outside dataflow.
By definition, all commits interacting with features through inside dataflow also structurally intercact with them.
From previous explanations, we also know these commits are almost identical to the entire set of commits with structural interactions.
It follows that commits part of structural CFIs must also have a high, albeit slightly lower, chance to affect features through outside dataflow.
We compare this probability to the probability of any active commit to interact with features through outside df in table \ref{tab:commit_dfbr_rel_table}.
The strongest contrast occurs for \textsc{xz}, where 41.7\% of commits structurally interacting with features, interact with other features through outside df, making them 4.8 times more likely to do so compared to any active commit of \textsc{xz} at 8.6\%.
The contrast is slightly weaker for \textsc{bzip2} with a 3.1 times higher likelihood and according percentages of 66.7 and 21.6\% respectively. 
\text{gzip} has the weakest contrast at 1.58 and respective probabilites of 59.6 and 38.1\%. 

\begin{figure}[htbp]
  \centering
  \includesvg[height=8cm]{gfx/results/RQ2/proportional_commit_dfbr_plot.svg}
  \caption{Proportional Dataflow-Plot for Commits}
  \label{fig:commit_dfbr_plot}
\end{figure}

\begin{table}[t]
\caption{Additional Information for Dataflow Analysis of Commits}
\label{tab:commit_dfbr_table}
\begin{tabular}{llrr}
 Projects & Number of Active Commits & Probability for Commit to be part of dataflow CFI \\
 	  & 			     & given that it is part of structural CFI \\
xz & 1039 & 0.883 \\
gzip & 194 & 0.933 \\
bzip2 & 37 & 0.889 \\
\end{tabular}
\end{table}

\begin{table}[t]
\caption{Relating Inside Dataflow to Outside Dataflow}
\label{tab:commit_dfbr_rel_table}
\begin{tabular}{llrr}
 Projects & Probability for Commits Part of Structural CFIs & Same Probability Given 	\\
 	  & to Affect other Features Through Outside DF     & Any Active Commit		\\
xz & 0.417 & 0.086 \\
gzip & 0.596 & 0.381 \\
bzip2 & 0.667 & 0.216 \\
\end{tabular}
\end{table}

\subsection*{\textbf{RQ3: Evaluation of Author Interactions}}\label{sec:eval_author_interactions}

\section{Discussion}\label{sec:discussion}

\subsection*{\textbf{RQ1: Discussion of Structural CFIs}}\label{sec:eval_struc_cfis}

\subsubsection*{Patterns of Feature Development}\label{sec:eval_feature_development}

- might notice that the fraction of potential to definite feature size is generally a bit higher than that of commits interacting at nd1 to those interacting at nd>1
- at first sight this might seem unusual since we are only differentiating between nesting degrees of structural CFIs and nesting degrees of instructions
- it's not surprising when looking at how we the nesting degree of structural CFIs in section \ref{sec:nesting_degree}
- 

- interesting to see that especially small features are partially or completely nested inside other features
- in future work it might be interesting to see whether there is some sort of correlation between the size of a feature and the relation of definite to potential feature size
- this could tell us whether and to what extent our initial observation holds up 
- this phenonemon also bears consequences on how commits are used in the development of features and the resulting CFIs
- if a developer wants to specifically change a feature that is nested inside a larger feature, the according commits will necessarily produce structural CFIs for both features
- in this context, it might be worth investigating whether such a nested feature implements separate or additional functionality of the feature it is nested inside
- this would decide whether the respective structural CFI with the larger feature 

- correlation and its p-values highly dependent of number of datapoints 
- the more datapoints the lower the p-values get, of course only given that the correlation coefficient is high in the first place
- it makes more sense to consider projects with many features so that we get more trustful statistical data
- when testing out different ways to measure correlations we realized that considering data of all projects in a sole dataset doesn't make sense
- the number of commits used to implement a feature of similar size is very different from project to project
- for example \textsf{verbosity} in \textsc{bzip2} with size ~1100 takes 7 commits, \textsf{force} in \textsc{gzip} with size ~900 takes ~37 commits, \textsf{Verbosity} in \textsc{xz} with size ~800 takes 22 commits
- xz has

- 

\subsubsection*{Usage of Commits in Feature Development}\label{sec:eval_commit_usage}































\section{Threats to Validity}\label{sec:threats}

In this section, discuss the threats to internal and external validity.
