%************************************************
\chapter{Evaluation}\label{ch:evaluation}
%************************************************

This chapter evaluates the thesis core claims.
At first, we describe the results of our three RQs in \autoref{sec:results}.
Following this, we dicuss our results and to what extent they answer our posed research questions.
In \autoref{sec:threats}, we focus on internal and external threats to the validity of our findings and gathered data. 

\section{Results}\label{sec:results}

Here, we evaluate the results of each RQ separately. 
As in \autoref{ch:methodology}, we divide the first two RQs into two sub-sections each.
Most of our results are represented by plots with at least one figure containing them per RQ and sub-section.
Important statistical values of the examined projects, which we refer to in the text, are additionally shown in tables.

\subsection[RQ1]{Results: RQ1} 
\label{sec:eval:RQ1}

Examining the structural CFIs of different projects can give us insights into the patterns of feature development and the usage of commits therin.
We first generally desribe our results with the help of \autoref{fig:feature_sfbr_plot} and \autoref{fig:commit_sfbr_plot} as well as the tables \ref{tab:feature_sfbr_table} and \ref{tab:commit_sfbr_table}.
We also explain particularly interesting results of individual commits and features by investigating their specific purpose and properties.

\subsubsection*{Patterns of Feature Development}\label{sec:eval_feature_development}

In the first part of RQ1, we examine the number of commits involved in the development of a feature and relate it to its size.
Figure \ref{fig:feature_sfbr_plot} illustrates our results in three different plots for each project.
Each row displays the results for one project with the name of the respective project being shown on the far left. 
In the first column, we show the number of structurally interacting commits for each feature in a bar plot.
For all projects, we notice a wide distribution of structurally interacting commits between features.
Numerous features, across all projects, interact with less than $\math{5}$ commits suggesting that they need very little work to be implemented in comparison to other features.
Both \textsc{xz} and \textsc{lrzip} have features structurally interacting with more than $\math{20}$ commits, while \textsc{gzip} even has four features that interact with more than $\math{60}$ commits.
With a mean of 29, the features of \textsc{gzip} have by far the highest number of interacting commits on average.
\textsc{xz}, \textsc{lrzip} and \textsc{bzip2} have much lower averages at $\math{9}$, $\math{16}$ and $\math{4}$ respectively.
As all projects are of a compression domain, we can find several features with the same general functionality across the examined projects.
The \textsf{verbosity}-feature structurally interacts with the most commits in \textsc{xz} and \textsc{bzip2}, while the same is not the case for the \textsf{verbose}-feature of \textsc{gzip}.
Although \textsc{gzip} encompasses the highest average number of interacting commits, its \textsf{recursive}-feature only interacts with $\math{2}$ commits, while the \textsf{recursive}-feature of \textsc{lrzip} interacts with $\math{24}$ commits. 

In the second column of \autoref{fig:feature_sfbr_plot}, we display the calculated feature sizes for each project.
Again, we see a wide range of different feature sizes within all projects.
Most notabely, there are large jumps between adjacent features, for example from \textsf{to\_stdout} with a size of $\math{450}$ to \textsf{no\_name} with a size of $\math{7300}$ in \textsc{gzip}.
Similarly to the number of interacting commits, \textsc{gzip} has by far the highest average feature size at $\math{2500}$.
The average feature sizes for the other projects range from $\math{190}$ for \testc{xz} to $\math{390}$ for \textsc{bzip2}. 
In \autoref{tab:feature_sfbr_table}, we display the average overlap degree of features for all projects.
Feature overlap is the least common for \textsc{xz} and \textsc{lrzip} and most common for \textsc{gzip} with an average of $\math{0.93}$ indicating that the majority of features overlap with other features to large extents.
This is also the case for the four, by far largest, features of \textsc{gzip}, namely \textsf{no\_name, method, force} and \textsf{decompress}.
Specifically, $\math{90}$ to $\math{100}$\% of the instructions constituting their size are identical among the mentioned features.
It is therefore not surprising that most, particularly $\math{66}$, of the commits interacting with each feature are identical for all four features.
For them, it is highly doubtful whether the size of a feature and the number of interacting commits reflect the actual number of \emph{implementing} commits and instructions of a specific feature. 

Finally, the metrics used in the two previously dicussed plots are compared to each other using the regression plot of \autoref{fig:feature_sfbr_plot}.
That is, we compare the size of a feature with the number of commits that structurally interact with it.
Each blue dot represents a feature and its coordinates are identical to the values of the bars in the two previous columns.
For both \textsc{xz} and \textsc{gzip}, we observe a strong positive correlation between the size of a feature and its number of structurally interacting commits.
Their linear correlation coeffecients are close to $\math{1}$ at $\math{0.91}$ and $\math{0.978}$ respectively with p-values smaller than $\math{10^{-4}}$.
% This data provides strong evidence that our initial notion, that larger features generally need more commits to be implemented, is correct.
This data provides strong evidence that the observed correlation is statistically significant.
While \textsc{bzip2} and \textsc{lrzip} have positive correlation coefficients of $\math{0.585}$ and $\math{0.968}$ respectively, their p-vlaues are relatively high at over $\math{0.1}$.
The high p-values can be explained by a lack of datapoints for \textsc{lrzip} and conflicting datapoints for \textsc{bzip2}.
For example, both the \textsf{opMode}- and \textsf{srcMode}-feature of \textsc{bzip2} structurally interact with $\math{6}$ commits, but encompass vastly different feature sizes.
Overall, the two projects do not produce conclusive statistical evidence that the size of a feature and the number of interacting commits are positively correlated.

\begin{table}[t]
\caption[Average Degree of Feature Overlap]{Average feature overlap degree of all projects}
\label{tab:feature_sfbr_table}
\centering
\begin{tabular}{l r}
\toprule
\textbf{Projects} & {\textbf{Avg. Overlap Degree} \\ 
\midrule
  xz    & $\math{0.34}$ \\
  gzip  & $\math{0.93}$ \\
  bzip2 & $\math{0.64}$ \\
  lrzip & $\math{0.37}$ \\
\bottomrule
\end{tabular}
\end{table}

\clearpage

\begin{figure}[htbp]
  \centering
  \includesvg[width=15.5cm]{gfx/results/RQ1/feature-sfbr-plot.svg}
  \caption[Feature Development]{The distribution of feature sizes and structurally interacting commits of features and their linear correlation}
  \label{fig:feature_sfbr_plot}
\end{figure}

\clearpage

\begin{figure}[htbp]
  \centering
  \includesvg[height=14cm]{gfx/results/RQ1/commit-sfbr-plot.svg}
  \caption[Feature-Related Concerns of Commits]{The distribution of the number of feature-related concerns for commits}
  \label{fig:commit_sfbr_plot}
\end{figure}

\subsubsection*{Usage of Commits in Feature Development}\label{sec:eval_commit_usage}

As discussed in section \ref{sec:meth:RQ1}, a best practice for commits in feature development is that a commit should generally deal with only one responsibility in relation to features.
We investigate to what extent this holds in our examined software projects by examining the number of feature related concerns of a commit.
% since we determined this to be a fitting estimator for the number of features a commit changes or implements.
The distribution of how many commits have a certain number of concerns is displayed in \autoref{fig:commit_sfbr_plot}.
\textsc{xz}, \textsc{gzip} and \textsc{lrzip} show similar distributions, which is why we discuss them now and \textsc{bzip2} later.
For \textsc{xz}, \textsc{gzip} and \textsc{lrzip}, we note that the majority of commits only have single feature-related concern.
The according percentages for commits with a single concern among all considered commits are $\math{72}$\%, $\math{69}$\% and $\math{81}$\%.
The commit count gradually drops with an increasing number of concerns until it subsides to $\math{0}$ at an x-value of $\math{7}$, $\math{6}$ and $\math{4}$ respectively.
Interestingly, three commits of \textsc{gzip} have more than $\math{10}$ concerns with the commit \textsf{33ae4134cc} even encompassing 47 concerns.
Said commit originally introduced the \textsl{gzip.c}-file containing the \textsf{main}-function among other things.
The exceptionally high number of concerns of the commit can be explained by the fact that many of \textsc{gzip}'s $\math{14}$ features are partially implemented within \textsl{gzip.c}.
Additionally, the code of features heavily overlaps with each other, which means that the instructions stemming from said code encompass many different combinations of feature regions. \\
For \textsc{bzip2}, there are much less commits used in feature development compared to the other projects with only $\math{9}$ commits part of structural CFIs.
The distribution consists of two clusters, the first being at a single concern and the second cluster being located between $\math{7}$ and $\math{10}$ concerns.
The second cluster encompassing $\math{5}$ commits is slightly bigger than the first cluster with a commit count of $\math{4}$.
Since we are only dealing with a few commits here that still produce quite interesting and unique data, we have a closer look at the purpose of these commits and relate it to the number of their concerns.
We find that all commits part of the second cluster were used to publish new versions of \textsc{bzip2}, always encompassing over $\math{1000}$ additions.
Three out of the four commits part of the first cluster introduced minor changes and bug fixes, never changing more than $\math{30}$ source-code lines.
The remaining commit updated \textsc{bzip2} to version 1.0.4 fixing minor bugs from the previous version with many of the added source-code lines being used for comments. 

\begin{table}[t]
\caption[Commit Concerns on Average]{Average number of concerns for a commit before and after filtering large commits}
\label{tab:commit_sfbr_table}
\centering
\begin{tabular}{l r r}
\toprule
\textbf{Projects} & \textbf{Avg. Concerns} & \textbf{After Filtering Large Commits} \\ 
\midrule
  xz    & $\math{1.48}$ & $\math{1.29}$ \\
  gzip  & $\math{2.40}$ & $\math{1.55}$ \\
  bzip2 & $\math{5.11}$ & $\math{4.62}$ \\
  lrzip & $\math{1.30}$ & $\math{1.30}$ \\
\bottomrule
\end{tabular}
\end{table}

In \autoref{tab:commit_sfbr_table}, we display the average number of feature related concerns within a project both before and after filtering exceptionally large commits.
The first column contains the project to which the averages ​​in their respective row belong.
In the following column, we show the initial averages before applying the mentioned restriction.
\textsc{xz} and \textsc{lrzip} encompass the lowest average number of concerns at $\math{1.48}$ and $\math{1.3}$ respectively.
Although the distribution of \textsc{gzip} shown in \autoref{fig:commit_sfbr_plot} is similar to those of the formerly mentioned projects, its initial average is comparatively high at $\math{2.4}$.
The main cause for this are the three discussed commits of \textsc{gzip} with exceptionally many concerns.
After filtering large commits within a project, we note that the averages of \textsc{xz}, \textsc{lrzip} and \textsc{gzip} become more similar.
While the average slightly decreased for \textsc{xz} to $\math{1.29}$, it stayed the same for \textsc{lrzip}.
The three dicussed commits of \textsc{gzip} were part of the filtered commits, which explains the large drop of its average to $\math{1.55}$. \\
Unsurprisingly, the initial average of \textsc{bzip2} is by far the highest among all projects.
Since most of its commits are relatively large, this is also the reason why they are not excluded from our analysis. 
Here, only one commit with $\math{9}$ concerns is removed, which lowers the average to $\math{4.58}$.

We also performed a qualitative analysis of the filtered commits to check whether our suspicion that they were mostly used to refactor code is true.
We find that many of them were used to import releases of the projects to Git.
The fact that such commits exist is unsurprising considering that the investigated tools have been published before the release of Git or before Git was widespread.
While their purpose might not be refactoring code, it does make sense to filter these commits as they are not accurately depicting the development process of the projects itself or of their features.
Only two out of the eighteen commits we filtered in all projects were actually used to refactor code, specifically moving contents between files or adapting the code to a newer version of C.
For half of all exceptionally large commits we found no reason, neither refactoring code nor importing the project to Git, to be left out of our analysis.

\subsection[RQ2]{Results: RQ2}\label{sec:eval:RQ2}

By investigating dataflow-based CFIs, we are able to determine the proportion of commits with dataflow interactions in a project as well as the number of commits that affect a feature through dataflow.
We factor in whether a dataflow interaction between a commit and a feature coincides with a structural interaction, to differentiate between dataflow stemming from outside or inside the regions of a feature.
This way, we aim to underline our hypothesis that commits inside of features are more likely to affect them trough dataflow, allowing us to especially focus on commits with an outside dataflow origin.
Our results regarding the first part of RQ2 are shown in \autoref{fig:commit_dfbr_plot} and in the tables \ref{tab:commit_dfbr_table}, \ref{tab:commit_exclusive_and_partial_dfbr_table} and \ref{tab:commit_dfbr_rel_table}.
Figure \ref{fig:feature_dfbr_plot} displays our results for the features of a project and the commits that affect them through dataflow.

\begin{table}[t]
\caption[Dependency Between Structural and Dataflow-based CFIs]{Relation between structural and dataflow-based CFIs}
\label{tab:commit_dfbr_table}
\centering
\begin{tabular}{l r r}
\toprule
\textbf{Projects} & \textbf{Active Commits} & \textbf{P($\exists$F: C $\rightsquigarrow$ F $\mid$ $\exists$F: C $\circledcirc$ F)} \\
\midrule
  xz    & $\math{1039}$ & $\math{0.883}$ \\
  bzip2 & $\math{37}$ & $\math{0.889}$ \\
  gzip  & $\math{194}$ & $\math{1.000}$ \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection*{Proportion and Dependencies of Commits Affecting Features through Dataflow}\label{sec:eval_commit_dfbr}

At first, we examine the fraction of commits affecting features through dataflow among the \emph{active} commits of a project.
There, we also evaluate the effects and dependencies of commits part of structural CFIs on said fraction.
Following this, we evaluate the proportion of outside dataflow origins within the set of commits with dataflow interactions.
This also allows us to quantify the commits whose interactions with features can only be discovered through our dataflow analysis.

The number of active commits are shown in the second column of \autoref{tab:commit_dfbr_table} for each project.
We determined \textsc{xz} to have the highest number of active commits at $\math{1039}$, while \textsc{bzip2} only has a tiny fraction of that at $\math{37}$.
In the first plot of \autoref{fig:commit_dfbr_plot}, the bars colored in red show what percentage of commits interact with features through dataflow.
We notice that the respective percentages are vastly different from project to project.
A significant portion of active commits in \textsc{gzip} are part of dataflow-based CFIs at $\math{37.1}$\%\footnote{this percentage is calculated only considering active commits of \textsc{gzip} and not its sub-module \textsc{gnulib}; we explained this choice more thouroughly in the Operationalization chapter}.
This percentage drops to about $\math{27}$\% for \textsc{bzip2}, with another large reduction to $\math{11.3}$\% for \textsc{xz}.
This means that more than every third active commit in \textsc{gzip}, roughly every fourth in \textsc{bzip2} and every ninth in \textsc{xz} affects features through dataflow.
The bars colored in grey display the fraction of active commits structurally interacting with features.
In addition to the obvious fact of how often commits are used to implement features, this also bears important consequences for the fraction of commits with dataflow interactions.
Comparing the two bar types, we notice that the percentage of commits with structural interactions is lower than the percentage of commits with dataflow interactions for each project.
\begin{figure}[t]
  \centering
  \includesvg[height=10cm]{gfx/results/RQ2/proportional_commit_dfbr_plot.svg}
  \caption[Dataflow Proportion/Origin for Commits]{The proportion of commits with dataflow interactions and their dataflow origin}
  \label{fig:commit_dfbr_plot}
\end{figure}
This phenomenon can be explained considering the values presented in the third column of \autoref{tab:commit_dfbr_table}.
There, we show the probablity for a commit to be part of any dataflow-based CFI, given that said commit is part of any structural CFI.
We see that the probabilities are slightly below $\math{90}$\% for \textsc{xz} as well as \textsc{bzip2} and even at $\math{100}$\% for \textsc{gzip}.
This means that by only taking into account commits part of structural CFIs, we already encounter a lot of commits that affect features through dataflow.
If we then consider the entire set of active commits, the number of commits with dataflow interactions will likely exceed the number of commits with structural interactions.
This also implies that most, if not all, commits constituting the grey bar of a project in turn constitute parts of the red bar as well.

We explore the topic of different dataflow interaction types more thoroughly with our second plot, which focuses on the \emph{origin} of dataflow.
There, we have a closer look at the commits affecting features through dataflow and where their dataflow stems from\footnote{for \textsc{gzip}, we now factor in every commit part of dataflow interactions; namely the commits stemming from its sub-module \textsc{gnulib} as well}.
In the second plot of \autoref{fig:commit_dfbr_plot}, we separate the commits with dataflow interactions into three categories based on dataflow origin.
The first category, shown as the bar colored in blue, represents commits that only interact with features through outside dataflow.
They make up the majority of commits for \textsc{xz} at $\math{56.4}$\%, but only $\math{20}$\% as well as $\math{25.4}$\% of commits for \textsc{bzip2} and \textsc{gzip} respectively.
The second category represents commits that interact with features through outside and inside dataflow.
Logically, these commits affect at least two features through dataflow and only structurally interact with a subset of them.
Surprsingly, they form the majority of commits for \textsc{bzip2} and \textsc{gzip} at $\math{60}$ and $\math{44.3}$\% respectively and around $\math{20}$\% of commits for \textsc{xz}.
The proportion of commits that only interact with features through inside dataflow varies less between the projects.
\textsc{gzip} has the highest percentage at $\math{31.3}$\%, \textsc{bzip2} the lowest at $\math{20}$\% with \textsc{xz} inbetween the two at $\math{23.9}$\%.
\begin{table}[t]
\caption[Interactions only Through Dataflow]{Commits exclusively/partially interacting with features \emph{only} through dataflow}
\label{tab:commit_exclusive_and_partial_dfbr_table}
\centering
  \begin{tabular}{l*4{r}}
    \toprule
    \multirow{2}{*}{\textbf{Projects}} &
      \multicolumn{2}{c}{\textbf{Commit Count}} &
      \multicolumn{2}{c}{\textbf{Percentage of all active commits}} \\
      & {Exclusive} & {Partial} & {\ \ \ \ \ \ \ \ Exclusive} & {Partial \ \ \ \ \ \ \ \ } \\
      \midrule
    xz & $\math{66}$ & $\math{23}$ & $\math{6.4}$ & $\math{2.2}$ \ \ \ \ \ \ \ \ \ \\
    bzip2 & $\math{2}$ & $\math{6}$ & $\math{5.4}$ & $\math{16.4}$ \ \ \ \ \ \ \ \ \ \\
    gzip & $\math{8}$ & $\math{46}$ & $\math{4.1}$ & $\math{23.7}$ \ \ \ \ \ \ \ \ \ \\
    \bottomrule
  \end{tabular}
\end{table}

Combining the data presented in both plots, we calculated the number and percentage of active commits in a project whose interactions with features were exclusively discovered by our dataflow analysis.
The respective values are shown in \autoref{tab:commit_exclusive_and_partial_dfbr_table} on the left-hand side of the second and third column.
With a count of $\math{66}$, most commits were revealed for \textsc{xz}, although its percentage remains rather small at $\math{6.4}$\% due to its high number of active commits.
The percentages of \textsc{gzip} and \textsc{bzip2} are comparatively small at $\math{4.1}$ and $\math{5.4}$\% respectively.
On the right-hand side of the columns in \autoref{tab:commit_exclusive_and_partial_dfbr_table}, we display the number and percentage of commits where only a subset of their interactions with features was discovered exclusively by our dataflow analysis.
These commits are most common in \textsc{gzip} with a count of $\math{46}$ making up almost every fourth active commit at $\math{23.7}$\%.
Similarly to the overall percentage of commits with dataflow interactions, they are less common in \textsc{bzip2} at $\math{16.4}$\% and least common in \textsc{xz} at $\math{2.2}$\%. 
Interestingly, $\math{23}$ and, thus, the vast majority of commits affecting features in \textsc{gzip} exclusively through dataflow stem from its sub-module \textsc{gnulib}.
In contrast to this observation, only $\math{8}$ commits stemming from \textsc{gnulib} affect features in \textsc{gzip} both through inside and outside dataflow.
This constitutes a much lower number than the $\math{46}$ commits of \textsc{gzip}'s main code that do so.
Overall, we find that commits exclusively interacting with features through dataflow are more likely to stem from the sub-module \textsc{gnulib} than \textsc{gzip}'s main code, while the opposite is the case for commits partially interacting with features only through dataflow.

% commits of a sub-module are more likely to exclusively interact with features through dataflow
% one type of commit is more common in sub-modules than in the main code of a project and vice verse
We notice that commits interacting with features through inside dataflow have a high chance to also interact with \emph{other} features through outside dataflow.
By definition, all commits interacting with features through inside dataflow also structurally interact with them.
From previous explanations, we also know these commits are almost identical to the entire set of commits with structural interactions.
It follows that commits part of structural CFIs must also have a high, albeit slightly lower, chance to affect other features through outside dataflow.
We compare this probability to the probability of any active commit to interact with features through outside dataflow in \autoref{tab:commit_dfbr_rel_table}.
The strongest contrast occurs for \textsc{xz}, where $\math{41.7}$\% of commits structurally interacting with features interact with other features through outside dataflow, making them $\math{4.8}$ times more likely to do so compared to any active commit of \textsc{xz} at $\math{8.6}$\%.
The contrast is slightly weaker for \textsc{bzip2} with a $\math{3.1}$ times higher likelihood and according percentages of $\math{66.7}$ and $\math{21.6}$\% respectively. 
The project \textsc{gzip} has the weakest contrast at $\math{2.6}$ and respective probabilites of $\math{71.9}$ and $\math{27.8}$\%. 

\begin{table}[t]
\caption[Realting Outside Dataflow to Structural Interactions]{Relating outside dataflow to structural interactions}
\label{tab:commit_dfbr_rel_table}
\centering
\begin{tabular}{l r r}
\toprule
\textbf{Projects} & \textbf{P($\exists$F: C (out$\rightsquigarrow$) F $\mid$ $\exists$F: C $\circledcirc$ F)} & \textbf{P($\exists$F: C (out$\rightsquigarrow$) F)} \\ 
\midrule
  xz    & $\math{0.417}$ & $\math{0.086}$ \\
  bzip2 & $\math{0.667}$ & $\math{0.216}$ \\
  gzip  & $\math{0.719}$ & $\math{0.278}$ \\
\bottomrule
\end{tabular}
\end{table}

\clearpage

\begin{figure}[htbp]
  \centering
  \includesvg[width=15.5cm]{gfx/results/RQ2/feature_dfbr_plot.svg}
  \caption[Features Affected by Commits Through Dataflow]{The distribution and proportion of outside and inside commits affecting a feature through dataflow and their linear correlation to the size of a feature}
  \label{fig:feature_dfbr_plot}
\end{figure}

\clearpage

\subsubsection*{Understanding Features and the Commits Affecting them Through Dataflow}\label{sec:eval_feature_dfbr}

When examining the commits affecting a feature through dataflow, we differentiate between those located outside and those at least partially located inside of the feature they interact with.
Investigating the ratio of outside and inside commits allows us to determine whether most dataflow interactions with commits occur inside or outside of the regions of a feature.
In a second evaluation step, we also relate the two metrics to the size of a feature.
Furthermore, we put our hypothesis that the proportion of outside to inside commits of a feature decreases as its size increases to the test.

Our results are shown in \autoref{fig:feature_dfbr_plot} in three plots for each of our examined projects.
In column one of the respective figure, we display the number of outside and inside commits for each feature in a bar plot.
We note that the majority of features in \textsc{xz}, \textsc{gzip} and \textsc{lrzip} are affected by more outside than inside commits through dataflow.
For \textsc{xz} and \textsc{gzip} this is underlined in median-values of $\math{18.5}$ and $\math{54}$ for outside and $\math{6.5}$ and $\math{14}$for inside commits, respectively, among their features.
% mention dichomitry between gzip's four largest features and the rest??
For features of \textsc{xz} and \textsc{gzip} with more outside than inside commits, we also notice very high ratios of outside to inside commits.
They range from $\math{2}$ to $\math{9}$ in \textsc{xz} with a mean of $\math{4.4}$ and from $\math{3}$ to $\math{32}$ in \textsc{gzip} with a mean of $\math{10.8}$.
For features with more inside than outside commits affecting them through dataflow, we determined much lower ratios and according ranges of inside to outside commits.
They range from $\math{1.17}$ to $\math{1.44}$ in \textsc{xz} with a mean of $\math{1.3}$ and from $\math{2.3}$ to $\math{2.8}$ in \textsc{gzip} with a mean of $\math{2.5}$.
At least for these two projects, the number of outside commits is often not only slightly higher than the number of inside commits, but instead exceeds it by many maginutes.
% - due to the high degree of feature-nesting determined for \textsc{gzip} in the evaluation of RQ1, we decided to test  
% same not true for inside commits
The features of \textsc{bzip2} exhibit a different general behavior than the features of the projects discussed above.
Specifically, $\math{6}$ out of $\math{8}$ features encompass more or at least the same number of inside than outside affecting them through dataflow.
The range and maximum number of interacting commits is also much lower compared to the other examined projects. 

In the second column of \autoref{fig:feature_dfbr_plot}, we compare the number of inside and the number of outside commits of a feature with its size in a regression plot.
As suspected during the formulation of RQ2, we find a strong positive correlation regarding the inside commits of features across all projects.
Especially, the correlation coefficients for \textsc{xz}, \textsc{gzip} and \textsc{lrzip} range close to $\math{1}$ with a minimum value of $\math{0.935}$.
\textsc{xz} and \textsc{gzip} encompass p-values of less than $\math{10^{-4}}$ supporting a statisitically significant correlation.
The correlations regarding the outside commits affecting features through dataflow are vastly different from project to project.
\textsc{xz} is the only project with a strong positive correlation with a coefficient of $\math{0.824}$.
A low p-value of $\math{0.003}$ outside of our rejection interval makes the data seem statistically significant at first.
However, the dots of its regression plot are scattered rather randomly and the number of interacting commits generally does not increase with rising feature-size.
We determined the \textsf{Verbosity}-feature to be the main reason for our calculated strong positive correlation.
This becomes clear when we disregard \textsf{Verbosity} in our analysis, which results in the coefficient dropping close to $\math{0}$ and the p-value rising to $\math{1}$.
\textsc{gzip} encompasses a negative correlation coefficient of $\math{-0.772}$ and a p-value of $\math{0.002}$ justifiying the existence of significant statistical evidence.
The falling linear regression line is mainly formed by the two existing clusters, where one consists of four very large and the other cluster of nine relatively small features.
The former cluster consists of features that each interact with around $\math{30}$ outside commits through dataflow.
The cluster consisting of features with small sizes encompasses higher values between $\math{50}$ and $\math{65}$.
The only feature of \textsc{gzip} that cannot be assigned to a cluster is the \textsf{recursive}-feature, which rather fits into the first cluster according to its number of outside commits and into the second cluster according to its size.
In \textsc{bzip2}, the number of outside commits affecting a feature through dataflow and its size are un-correlated.
A correlation coefficient of $\math{0.545}$ and a high p-value of $\math{0.633}$ do not provide significant statistical evidence for the existence of a correlation in \textsc{lrzip}. 

In the third column of \autoref{fig:feature_dfbr_plot}, we finally relate the size of a feature to its proportion of outside to inside commits.
At first, we notice that the calculated correlation coefficients are negative across all projects.
The fact that the coefficients of \textsc{xz} and \textsc{bzip2} are close to $\math{0}$ and the p-values correspondingly high is illustrated by the rather random distribution of dots in their respective regression plots.
Their dataset should therefore not be regarded as correlated.
Compared to the aforementioned projects, \textsc{gzip}'s p-value of $\math{0.035}$ is very low, while it also has a lower correlation coefficient of $\math{-0.588}$.
Similarly to previous plots of \textsc{gzip}, we can identify two clusters.
A cluster of dots is again formed by the four largest features, encompassing proportions of outside to inside commits slightly below $\math{0.5}$.
The other cluster is located at the beginning of the x-axis with a wide spread across the y-axis indicating its low feature size and a wide range of proportions from $\math{3}$ to $\math{32}$.
The coefficient of \textsc{lrzip} is by far the smallest among all projects at $\math{-0.99}$, but the small number of features results in a p-value of $\math{0.088}$.
It follows that none of the determined negative correlations are statistically significant, as their p-values fall into our rejection interval of $\math{97.5}$\%.

\subsection[RQ3]{Results: RQ3}\label{sec:eval:RQ3}

Here, we examine the authors structurally interacting with features, i.e. those involved in their development, as well as the authors introducing commits affecting features through outside dataflow.
As the sets of authors interacting with features structurally or through outside dataflow can overlap, we also investigate the number of authors that can only be discovered with our dataflow analysis.
The respective values for a feature's structural, dataflow and unique dataflow authors are shown in the first column of \autoref{fig:author_cfi_plot} for each project.
In the second column of said figure, we also display our results regarding the comparison of the two metrics with the size of a feature. 

The project \textsc{xz} has mostly been developed by a single author, which is reflected in our results.
As can be seen in \autoref{fig:author_cfi_plot}, all except one feature have  been exclusively implemented by the same author.
We can conclude that this also is the developer affecting features through outside dataflow, since no feature has unique dataflow authors.
The features of \textsc{bzip2} mostly interact with one author structurally and one or two authors via dataflow.
Except for the \textsf{keepInputFiles}-feature, our dataflow analysis discovered one unique interacting author for each feature.
This changes for \textsc{lrzip}, where our dataflow analysis reveals at least $\math{2}$ and up to $\math{5}$ unique authors for the three examined features.
$\math{55}$\% of the authors structurally interacting with a feature in \textsc{bzip2} and \textsc{lrzip} also interact with it through outside dataflow.
Overall, the linear regressions relating the size of a feature to the number of its structural or dataflow authors show no significant correlation for the three mentioned projects.

The project \textsc{gzip}, on the other hand, provides us with much more comprehensive results.
In the bar plot of \textsc{gzip} in \autoref{fig:author_cfi_plot}, we can see that every feature has a large number of interacting authors.
The combined number of unique authors that interact with a feature in any way can be computed by the sum of its structural and its unique dataflow authors.
This means that the lowest number of interacting authors is $\math{7}$ for the \textsf{recursive}-feature and the highest $\math{14}$ for the \textsf{force}-feature.
On average, a feature has more dataflow than structural authors with respective averages of $\math{9.1}$ and $\math{5.7}$.
The average number of unique dataflow authors is $\math{5.9}$, which means that our dataflow analysis discovers many additional interacting authors for the features in \textsc{gzip}.
The number of structurally interacting authors, i.e. authors implementing a feature, range from $\math{2}$ to $\math{13}$ between the features of \textsc{gzip}.
There is less variance in the number of a feature's outside dataflow authors ranging from $\math{7}$ to $\math{12}$.
Features with relatively few structural authors, have a comparatively high number of dataflow authors.
Features with many structural authors, starting from the \textsf{no\_name}-feature, have less outside dataflow authors.
At the same time, the number of their unique dataflow authors is comparatively low implying that most of them also structurally interact with the according features.
The fact that the group of features with few structural authors has much more dataflow authors conditions them to have many unique dataflow authors.
Still, more than $\math{80}$\% of their structural authors also interact with them through outside dataflow.
This is not the case for the group of features with many structural authors, where this is the case for less than $\math{45}$\% of them.
Overall, there is a $\math{47}$\% likelihood for the structural author of any feature to interact with the same feature through outside dataflow.
Similarly to the bar-plot of \textsc{gzip}, we notice two clusters when examining its regression plots in \autoref{fig:author_cfi_plot}.
The first cluster is made up of features with few structural authors whose respective sizes range between $\math{20}$ and $\math{450}$.
The second cluster consists of the four features who encompass more than $\math{10}$ structural authors and much higher feature sizes ranging from $\math{7400}$ to $\math{8200}$.
It is therefore unsurprising that we compute a strong positive correlation between the size of a feature and the number of its structurally interacting authors.
The respective correlation coefficient is $\math{0.98}$, while the p-value is smaller than $\math{10^{-4}}$ providing evidence for a statistically significant correlation.
Regarding the dataflow authors of features, we note two similar clusters that consist of the same features of small and much larger sizes respectively.
Now, the smaller features have slightly more dataflow authors centering around $\math{10}$ than the much larger features with an average of $\math{5}$.
This shows itself in a strong negative correlation coefficient of $\math{-0.872}$ and a p-value of less than $\math{10^{-4}}$ falling out of our rejection interval of $\math{97.5}$\%.

\begin{figure}[htbp]
  \centering
  \includesvg[width=15.5cm]{gfx/results/RQ3/author-cfi-plot.svg}
  \caption[Features Interacting with Authors]{The distribution of structural, outside dataflow and unique dataflow authors of features and their linear correlation to the size of a feature}
  \label{fig:author_cfi_plot}
\end{figure}

\clearpage 

\section{Discussion}\label{sec:discussion}

In this section, we first formulate whether and how the previously evaluated results can answer our research questions.
We also relate findings between the RQs and their sub-sections to highlight similarities and differences between them.
Besides that, we look at possible reasons for our results and further interesting thoughts related to them.

\subsection[RQ1]{Discussion: RQ1}\label{sec:disc:RQ1}

Generally, we have seen our expectations for possible results of RQ1 mostly confirmed.
Here, we briefly formulate our most important results, which we discuss in more detail in the following sub-sections.
Firstly, we find sufficient evidence to support the notion that the number of commits used to develop a feature is strongly positively correlated with the size of the code implementing its functionality. 
Secondly, we have high confidence that most commits within our examined projects only deal with a single responsibility in relation to features.

\subsubsection*{Patterns around Feature Development}

The features within the examined projects exhibit a wide distribution of structurally interacting commits and sizes.
We consider this as a clear indication that the number of commits as well as the extent of source-code used to implement a feature varies a lot between them.
The range of least to most interacting commits and lowest to highest feature size is hereby dependent on the specific project.

Determining the average overlap degree of features within a project showed us that, especially in the case of \textsc{gzip}, feature overlap is more common than initially expected.
Most of the computed sizes of \textsc{gzip}'s respective features are made up of instructions that are part of multiple feature regions besides its own. 
This makes it difficult to clearly interpret the data, as the number of instructions that actually implement a feature can differ greatly from our observed size. 
This phenonemon also bears consequences on they way commits are used in feature development and the CFIs resulting from this. 
If a developer wants to specifically change a feature nested inside other features, the according commit will necessarily produce structural CFIs with several features.  
This also casts some doubt how well the structural interactions of a feature with a high overlap degree accurately represent its development.
A concrete example of this are the four, by far largest, features of \textsc{gzip}.
In our evaluation of RQ1, we have already explained that they share the vast majority of instructions constituting their size as well as the commits that structurally interact with them.
In these cases, it would be extremely helpful to be able to decide whether the respective instructions and commits are actually \emph{implementing} commits and instructions of a particular feature.
While solving this problem goes beyond the scope of this work, future research can produce more informative results by adressing and solving this subject.

We employ the pearson correlation coefficient to investigate the linear relationship between the size of a feature and the number of commits structurally interacting with it. 
While we find high correlation coefficients of $\math{0.9}$ and above, the p-values of \textsc{lrzip} and \textsc{bzip2} are not low enough to justify the data to be statistically significant.  
We know that p-values are highly dependent on the number of datapoints, that is, the number of features of a project. 
Logically, projects with fewer features have less datapoints resulting in their p-values being quite high and falling into our rejection interval. 
With $\math{10}$ and $\math{14}$ features respectively, \textsc{xz} and \textsc{gzip} have by far the most datapoints and according p-values of less than $\math{10^{-4}}$ giving us most significant evidence for a strong positive correlation. 
Due to the above-mentioned problems caused by the high feature overlap degree of \textsc{gzip}, the significance of the found strong positive correlation is somewhat weakened.
On the other hand \textsc{xz} has a relatively low overlap degree, but still shows the same strong positive correlation.
Therefore, we are still able to confirm our original hypothesis of a strong dependency between the size of the implementing code and the number of implementing commits of a feature. 

% - therefore, future research should prefer projects with at least 10 features so that correlations and other measurments produce trustful statistical data. \\
A possibility to circumvent the problem of too few datapoints could be to combine features of all projects into one big dataset.  
Here, we are faced with the issue that the way commits are used among projects might differ drastically. 
In our case, the number of instructions per structurally interacting commit of a feature varies greatly from project to project.  
The respective values are $\math{17}$ for \textsc{xz}, $\math{48}$ for \textsc{gzip}, $\math{87}$ for \textsc{bzip2} and $\math{13}$ for \textsc{lrzip}.  
This means that features of a similar size have, on average, vastly different numbers of structurally interacting commits across different projects. 
Upon these considerations, we are of the opinion that it makes more sense to test correlations within projects as we have done in this work. 

\subsubsection*{Usage of Commits in Feature Development}

In \autoref{sec:commit_concerns}, we explained that due to feature overlap the number of features a commit structurally interacts with can be a faulty estimate of how many responsibilities in relation to features a commit usually deals with.
To achieve a more accurate measure, we introduced the concept of feature-related concerns of a commit (\autoref{def:commit_concerns}).
There, we do not look at the structural CFIs of a commit separately, but rather focus on the entirety of them and the instructions they stem from.
As long as the CFIs occur in the same feature related location, i.e. in instructions belonging to regions of the same set of features, we assume that the commit deals with a single responsibility.
A concrete example of why the feature related concerns can be a more accurate estimate for the number of feature-related responsibilites is shown in \hyperref[lst:commit_concerns]{listing 3.2}.
% of course not 100\% accurate, for example when two features are implemented within the exact same code-space => we suspect this does not happen often 
Excluding \textsc{bzip2}, roughly $\math{70}\%$ of commits only have a single feature-related concern in the remaining projects.
Despite this, \textsc{gzip}'s average is quite high at $\math{2.4}$, in comparison to \textsc{xz} and \textsc{lrzip} with an average of $\math{1.48}$ and $\math{1.3}$ respectively.
It decreases to $\math{1.55}$ after filtering large commits, such as commit \textsf{33ae4134cc} with an exceptionally high number of $\math{47}$ feature-related concerns.
Its purpose was to import the original \textsl{gzip.c}-file into the repository, which justifies the exclusion of the commit.

To summarize our results, most commits of \textsc{xz}, \textsc{gzip} and \textsc{lrzip} have only one feature-related concern with an average of less than $\math{1.6}$ after filtering large commits. 
Given that the feature-related concerns accurately reflect the number of responsibilites for most commits, we can confirm our initial thesis. 
Thus, the majority of commits that affect the code of features only deal with a single responsibility in relation to features.
% commit can have other responsibilites not in relation to features => examine them as well
% how can we determine whether they are done for the same purpose => determine whether dataflow flows into the respective features
% At first sight, this finding does not align with the observation of a previous study by \citet{michelon2021lifecycle} that commits are more likely to change multiple features at once than only one specific feature.

In contrast to three projects discussed above, \textsc{bzip2} has shown to be a project whose results need to be treated more carefully.
Only $\math{9}$ commits structurally interact with its features, encompassing much less datapoints compared to the other examined projects.
$\math{6}$ out of $\math{9}$ commits were used to import the initial project to Git and iteratively update the code to newer versions.
These commits are not exemplary of the common development process of a project and its features in a Git repository.
The actual development of the tool in the Git repository began after \textsc{bzip2} was finally updated to version 1.0.6.
The remaining $\math{3}$ commits introduce minor changes and small bug fixes to the respective features they interact with.
This means that the features of \textsc{bzip2} were largely already implemented when the actual development within the repository started.
Thus, the average number of concerns of a commit as well as their overall distribution are not good representatives of other projects developed in Git. 

\subsection[RQ2]{Discussion: RQ2}\label{sec:disc:RQ2}

We are able to confirm our hypothesis discussion in \autoref{sec:combination_cfis} that structural CFIs heavily coincide data flow-based CFIs.
This allows us to formulate a lower bound for the proportion of commits with dataflow interactions, namely the proportion of commits with structural interactions.
While there exists a lot of variation in the proportion of commits affecting features through dataflow within the examined projects, said proportion heavily depends on the extent of feature code in a project and the number of commits implementing said code.
Furthermore, our dataflow analysis uncovers a significant amount of interactions between commits and features that we cannot discover with our previous structural analysis.
We are also able to uncover that commits that already touch feature code have an increased probability of influencing other features via outside dataflow.
We transfer this knowledge to features and the commits affecting them through dataflow by determining that many of their outside dataflow commits are also part of other features.
In general, the majority of features are influenced by outside commits, whereas this dataflow often originates within other features.
We find no statistically significant correlation between the number of outside commits of a feature and its size.
This also applies to the proportion of outside to inside commits, although we suspect that more data points and examined projects could lead to more substantive evidence here.

\subsubsection*{Proportion and Dependencies of Commits Affecting Features through Dataflow}

We have seen that the proportion of commits part of dataflow-based CFIs varies a lot between our examined projects.
While only $\math{11}$\% of active commits in \textsc{xz} affect features through dataflow, with $\math{37}$\%, a significantly higher proportion of active commits do so in \textsc{gzip}.
One major reason for the discussed differences is the fact that the proportion of structural commits acts as the \emph{lowest bound} for the proportion of commits with dataflow interactions.
As $\math{90-100}$\% of commits part of structural CFIs are also part of dataflow-based CFIs, the percentage of commits part of dataflow-based CFIs never falls below the percentage of commits part of structural interactions.
The effects of said lowest bound can be recognized in the first plot of \autoref{fig:commit_dfbr_plot}, where the rank of a project among the dataflow proportions of commits reflects its rank among the structural proportions.
That is also because the percentages of commits whose interactions with features are only discovered by our dataflow analysis are the same or only a fraction of the percentages of those with structural interactions.
Similar strong differences in the structural proportions of commits can thus also be found in the dataflow proportions.
Including structural CFIs in the evaluation of our dataflow-based CFIs is definitely necessary to properly categorize their proportion and the new information they could add to the analysis of a project.
A substantial share of the examined dataflow interactions stem from our previously investigated set of structural interactions.
As we have determined structural CFIs to heavily coincide with dataflow-based CFIs, we already know of this set of dataflow interactions prior to our dataflow analysis. 

Nevertheless, we believe that our dataflow analysis is essential in fully assessing commit-feature interactions and their frequency within a project.
For \textsec{xz}, the majority of commits interacting with features are exclusivly revealed by our dataflow analysis.
For $\math{8}$, $\math{21}$ and $\math{28}$\% of active commits in \textsc{xz}, \textsc{bzip2} and \textsc{gzip} respectively, it revealed additional interactions with features that we could not discover with our structural analysis.
This means that the data of, on first sight unrelated, commits and features can be highly connected. 
% gnulib 31 commits discovered through dataflow analysis, substantial amount from the 84 in total of the gzip project

Besides that, we find that many commits interacting with features both structurally and through dataflow also interact with \emph{other} features \emph{only} through dataflow.
This lead us to examine whether commits structurally interacting with features are more likely to affect features through outside dataflow in comparison to any active commit.
We find sufficient evidence to support the notion that this is indeed the case, including an almost 5-times higher probability in \textsc{xz}.
This suggests that data, changed or allocated by a commit in one feature, is often used within a different feature again.
% Of course, it can also happen that a commit changes code outside of features in addition to feature code and the data flow into other features originates exclusively from the latter code.
% With our current analysis in VaRA, we cannot determine the number of these occurrences and therefore exclude them from our analysis.
% However, we see little reason to assume that they influence our results to a statistically significant extent. 
% In RQ1, we saw that most commits only change one feature, so there is a strong suspicion that most commits that touch feature code only touch feature code.
Therefore, a developer changing code of a feature should be aware that data of said code has an increased probability to affect the functionality of other features.
This also provides evidence that feature code and remaining code of a program is more separate from each other than the initial percentage of commits with outside dataflow interactions would suggest.
When discussing the second part of RQ2, we seek to underline this notion by determining how often outside commits affecting a feature through dataflow, structurally interact with other features.

Lastly, we discuss the extent of feature code in a project and its consequences on the proportion of commits with structural as well as dataflow interactions.
In RQ1, we have confirmed that the number of commits structurally interacting with a feature is strongly positively correlated with its size for \textsc{xz} and \textsc{gzip}.
It follows that a higher extent of feature code implies a higher proportion of commits with structural interactions.
As the latter proportion acts as a lower bound for the proportion of commits with dataflow interactions, we assume the extent of feature code to also have a strong influence on said proportion.
At the same time, less feature code and a higher number of active commits could elavate the share of commits affecting features through outside dataflow.
This is due to a lower share of structurally interacting commits and therefore less inside dataflow as well as a higher number of active commits located outside of feature regions leading to more possible outside dataflow.
We decide to compute the extent of feature code in a project as the fraction of all instructions that are part of feature regions.
Thus, we determine the extent of feature code to be $\math{17.2}$\% in \textsc{xz} and $\math{57.6}$\% in \textsc{gzip}. 
In our evaluation we have also seen that \textsc{xz} encompasses five times as many active commits than \textsc{gzip}.
We find that our observations in RQ2 roughly match these values considering our previous explanations.
Accordingly, \textsc{xz} has a higher share of commits affecting features through outside dataflow but a substantially lower share of active commits part of dataflow interactions.
It should be noted however that the extent of feature code does not have an exact relation to the proportion of commits with structural interactions.
From \textsc{xz}'s $\math{17}$\% extent of feature code, we would expect a signficantly higher number than the $\math{5.8\%}$ of commits part of structural CFIs for example.

\subsubsection*{Understanding Features and the Commits Affecting them Through Dataflow}

Especially in the case of \textsc{xz} and \textsc{gzip}, we find significant evidence to support the notion that features are generally affected by more outside than inside commits through dataflow.
This means that the majority of commits affecting a feature through dataflow are located outside of the feature they interact with.
Thus, most of the data belonging to the detected interactions of features originates outside of their regions and subsequently flows into them.
The ratio of outside to inside commits is often extremely skewed towards outside commits, while the opposite is rarely the case and if so, to a much smaller degree.
One reason for this is that even features with little size are affected by many outside commits, but only few inside commits.
That is because the number of a feature's inside commits is strongly positively correlated with its size, while the same is not the case for a feature's outside commits.
Specifically, we do not find evidence to suggest that the size of a feature and the number of outside commits affecting it through dataflow are correlated in some way or another.
The positive correlation found for \textsc{xz} is mainly driven by its largest feature, where the correlation coefficient subsides to $\math{0}$ without it.
\textsc{gzip} shows a statistically significant negative correlation, \textsc{bzip2} no correlation and \textsc{lrzip} a statisitcally insignificant positive correlation.
From the previous explanations, it follows that the number of inside commits generally increases with rising size of a feature, while the number of outside commits is less predictable.
This observation supports the notion that the proportion of outside to inside commits of a feature and its size are negatively correlated.
While we determine the according linear correlation coefficients to be negative for all projects, they are rather high and their respective p-values too low to warrant significant evidence.
Still, most data points to the existance of a, ableit slight, negative correlation, which could be confirmed by investigating more projects.

During the evaluation of the first part of RQ2, we find that commits structurally interacting with features have an increased probability of influencing other features via outside dataflow.
To continue our investigation in this regard, we determine the proportion of outside commits of features that are part of structural CFIs as well.
The average proportions are $\math{0.41}$, $\math{0.59}$, $\math{0.75}$ and $\math{0.43}$ for the features of \textsc{xz}, \textsc{gzip}, \textsc{bzip2} and \textsc{lrzip}, respectively.
All features except \textsf{force} of \textsc{gzip} have proportions higher than $\math{0.2}$ and the majority of values range close to the average of a project.
We can therefore confirm that a significant proportion of the data that flows into a feature probably originates from or is modified in other features.
This also means that features are less likely to be influenced by commits not changing any feature code than our determined numbers of outside commits would suggest.

The regression plots of \textsc{gzip} show that their strong linear correlations are mainly caused by two clusters of features.
One cluster consists of large features with many inside and comparatively few outside commits, the other of features with a small size and significantly more outside than inside commits.
In the evaluation of RQ1, we explain that due to feature overlap the sets of commits that structurally interact with each feature from the first cluster are almost identical.
This suggests that the inside commits of said cluster are almost identical as well and that this could also apply to the outside commits of the two clusters.
Indeed, we determine the majority of outside commits from the features of each cluster to be identical.
The respective percentages are $\geq$$\math{60}$\% for the cluster encompassing the large features and $\geq$$\math{70}$\% for the cluster of the smaller features excluding \textsf{recursive}.
Thus, the two clusters are not formed by coincidence, but because features of a similar size are largely affected by the same set of outside commits.
For the first cluster, this phenonemon can be explained by the fact that its features share large portions of their code, which results in them interacting with the same commits by design.
At the same time, this is not, or only partially, the case for the features of the second cluster.
For them, we note that $\math{25}$ inside and $\math{17}$ outside commits from features of the first cluster make up almost all of their identical outside commits.
Interestingly, this relation is especially apparent for the smallest feature of \textsc{gzip}, \textsf{no\_time}, which only encompasses $\math{23}$ instructions and is fully located inside of the regions of the \textsf{force}-feature.
All of the $\math{65}$ commits affecting \textsf{no\_time} through outside dataflow are inside or outside commits of \textsf{force}.
Thus, we find that there also exists a lot of dataflow between features of the two clusters, where the code of the \textsf{no\_time}-feature acts as a main intersection of said dataflow.
This is another product of the high degree of feature overlap in \textsc{gzip}, where the features of the second cluster are often completely nested inside the larger features of the first cluster.
The data stemming from commits interacting with these large features eventually passes through the smaller features within them, making said commits interact with the nested features through outside dataflow.
A high degree of feature overlap can therefore not only lead to many features sharing the same structurally interacting commits, but also the commits affecting them through outside and inside dataflow.
% Abschließend ist festzuhalten, dass feature-nesting ebenfalls Auswirkungen auf die Interepretierbarkeit von den commits die feature über datenfluss beeinflussen, hat ->> Wieso?

\subsection[RQ3]{Discussion: RQ3}\label{sec:disc:RQ1}

We find that our dataflow analysis is able to reveal many additional developers that do not directly participate in the development of a feature, but rather contribute commits whose data is later used inside features.
In most features of \textsc{gzip}, \textsc{bzip2} and \textsc{lrzip}, we detect a similar or higher number of unique dataflow authors compared to the number of structural authors.
While most unique dataflow authors are naturally found for features with more dataflow than structural authors, there also exist unique dataflow authors for features with more structural authors.
That is because, for the three mentioned projects, on average $\math{53}$\% of structural authors also interact with their respective features via outside dataflow.
This means that, while likely developers of features do not always contribute commits affecting them through outside dataflow.
They also are not the ones generally introducing these commits, as the majority of features encompass more unique dataflow authors than structural authors.

The only statistically significant correlations relating the size of a feature to its number of interacting authors were produced by \textsc{gzip}.
Here, we are able to gather initial evidence that the number of authors implementing a feature strongly increases with its size.  
In contrast, we found the opposite to be true for the number of authors influencing it through outside dataflow. 
However, as only a single project produced statistically significant results, we consider the question to be completely open to further research. 
\textsc{xz} and \textsc{bzip2} are unsuitable for the computation of a significant correlation due to their small number of different authors interacting with features and \textsc{lrzip} due to its small number of features. 

The strong positive correlation of \textsc{gzip} in regards to its structural authors matches its correlation between the size of a feature and its number of structurally interacting commits in RQ1.
This is also the case for \textsc{gzip}'s strong negative correlation regarding its dataflow authors and the correlation calculated for the number of outside commits in RQ2.
Overall, we notice that the number of authors interacting with a feature reflects the length of the set of commits from which we have extracted the authors.
In \textsc{gzip}, the two are positively correlated with a coefficient of $\math{0.73}$ and a p-value of $\math{0.004}$ for the number of structural commits and authors and a coefficient of $\math{0.54}$ and a p-value of $\math{0.058}$ for the number of outside dataflow commits and authors.
Thus, the number of commits interacting with a feature can hint at the number of authors that interact with it.
One reason for these strong positive correlations is the high degree of feature overlap, which caused features of the two discussed clusters of \textsc{gzip} to have largely identical sets of interacting commits.
As the set of authors for a particular feature is extracted from the commits interacting with it, it is unsurprising that the authors interacting with features of each cluster are also largely identical.
This applies to $\math{85}$ to $\math{100}$\%, depending on the respective feature, of the structural authors of the four largest features. 
Similarly, the percentage of identical dataflow authors is $\math{67-80}$\% for the first cluster and $\math{75-100}$\% for the cluster of smaller features excluding \textsf{recursive}.
Thus, a high degree of feature overlap can lead to many features having the same set of interacting authors.
This makes it difficult to trace whether a certain set of authors has really implemented a certain set of features or whether, for example, only one author from the set has implemented one feature from the set. 

In \textsc{gzip}, a total of $\math{14}$ authors interact with features in any way, from which $\math{13}$ structurally interact with features and $\math{12}$ affect features through outside dataflow.
Only one author that does not touch any feature code affects features through dataflow and only two authors structurally interacting with features do not affect other features through outside dataflow.
Here it is important to note that all $\math{13}$ developers of \textsc{gzip}\footnote{The remaining author from the total of $\math{14}$ authors interacting with features stems from \textsc{gzip}'s used submodule \textsc{gnulib}} interact with features either structurally or through dataflow or both.
This is not surprising given \textsc{gzip}'s high extent of feature code making up the majority of its instructions.
That the extent of feature code plays a role in what share of authors in a project interact with features can also be seen for \textsc{bzip2} and \textsc{lrzip} with an extent of $\math{8.2}$\% and $\math{1}$\% respectively.
While there are $\math{19}$ and $\math{27}$ contributors to the Git-repositories of \textsc{bzip2} and \textsc{lrzip}respectively, there only exist $\math{4}$ unique structural authors of features in both projects.
The fact that \textsc{bzip2} only encompasses $\math{3}$ unique outside dataflow authors, while \textsc{lrzip} encompasses $\math{8}$, likely has to do with \textsc{lrzip} having many more active commits and overall contributors.

\section{Threats to Validity}\label{sec:threats}

In this section, we dicuss the internal and external threats to the validity of this work.
There are some potential threats to the internal validity of our gathered data, which stem from our implementation in VaRA. 
Concerning the external validity of our findings, most dangers stem from the selection of projects we investigate.

\subsection{Threats to Internal Validity}\label{sec:int_threats}

From the definition of \hyperref[def:feature_regions]{feature regions}, it follows that we implement feature regions in such a way that any instruction whose execution depends on a configuration variable is part of a feature region.
However, not every such instruction also implements the functionality of a feature, as can be seen in \hyperref[lst:feature_region_overapproximation]{listing 5.1}.
This means that the regions of a feature can overapproximate the instructions responsible for its functionality.
If the instructions the CFI of a feature occurs in are such overapproximated instructions, it follows that said CFI is overapproximated as well.
Since feature regions are used for computing both structural and dataflow-based CFIs, our generated reports likely contain overapproximated CFIs.

% Furthermore, \citet{sattler2023seal} explains that our deployed VaRA taint analysis does not necessarily detect all dataflows occuring in a program.
% This results in taints being underapproximated, meaning that some instructions are not tainted when they correctly should be.
% Thus, some dataflow interactions could be missed by our deployed commit-feature interaction analysis. 
% why? taint analysis applies sensible underapproximations as computing the anaylsis in a sound manner and in an inter-procedural setting is impossible
The detection and tracking of configuration variables stored in structs is currently being implemented in VaRA and was not usable for this work.  
Specifically, the configuration variables of some features in \textsc{xz} and \textsc{lrzip} cannot be detected, meaning that no CFIs can be collected for them. 
Logically, this affects the overall and project-specific results of our RQs.
For example, the percentage of commits with only one feature-related concern are likely lowered by considering less features. 

Especially in the case of \textsc{lrzip}, we work with a small number of features resulting in very few datapoints that can be used for the computation of our results.
Accordingly, the p-values of the linear correlations computed for \textsc{lrzip} always fall into our rejection interval and, thus, produce no statistically significant correlation.
Another problem considering \textsc{lrzip} is that we only examine a small proportion ($\math{30}$\%) of its existing features, which means that our results might not be representative for the entire project. 

In this work, we have discussed the issues that arise from feature overlap~(see \autoref{sec:feature_overlap}) in detail.
In particular, feature overlap becomes a threat to the internal validity of our work when the overlap is created by feature nesting.
While the code of a nested feature only implements functionality of one feature, it belongs to several feature regions.
Thus, said code can produce both structural as well as dataflow-based CFIs with features whose functionality it does not implement.
This is problematic, as our analysis cannot decipher which feature is being implemented in the case of code with feature nesting.
We therefore are not able to filter the respective interactions, which means that feature nesting is an additional cause for overapproximating CFIs. % factor of
Feature overlap that is created by structurally interacting features does not threaten our validity in such a way.
As the code where the respective overlap occurs coordinates the interplay between the involved features, it also implements functionality for all of them. 
In \autoref{sec:feature_overlap}, we mentioned that we currently cannot differentiate between the two discussed causes of feature overlap, which means that we cannot separare feature overlap into one that safe and one that is unsafe for our analysis. \\
% quantify frequency of feature nesting??

\begin{lstlisting}[language=python, caption={Example for the Overapproximation of Feature Regions}, label={lst:feature_region_overapproximation}]
1. if FeatureEncryption:                              %\vartriangleright% %FeatureEncryption%
2.    sendEncryptedMessage(message)                   %\vartriangleright% %FeatureEncryption%
3. else:                                              %\vartriangleright% %FeatureEncryption%
4.    sendMessage(message)                            %\vartriangleright% %FeatureEncryption%
\end{lstlisting}
\label{lst:feature_region_overapproximation}
The function of \textsf{FeatureEncryption} is to send the message encrypted. According to our definition of feature regions all instructions stemming from the shown lines of code belong to a region of \textsf{FeatureEncryption}, as their execution depends on the configuration variable of \textsf{FeatureEncryption}. However only instructions stemming from the lines $\math{1-2}$ implement the actual functionality of the feature. Thus our analysis overapproximates the lines $\math{3-4}$ to also belong to the feature.

\subsection{Threats to External Validity}

Our pool of investigated projects is limited and it is likely that the way commits and features are used in them is different to other projects to some extent.
In previous chapters, we mentioned that the chosen projects are rather small and from a compression domain.
This could mean that our findings might not be applicable for projects of larger sizes or of different domains.
As we already factor in the size of a feature in the analysis of our data, we are able to mitigate some doubts about the applicability of our results onto larger projects. 

Apart from the general selection of our examined projects, \textsc{bzip2} in particular is a project whose results must be treated with caution.  
In the \hyperref[sec:disc:RQ1]{discussion of RQ1}, we already explained that the overall project and its features were largely already implemented when the actual development in the Git repository started.
This is reflected in a total of only $\math{37}$ active commits and a maximum of $\math{7}$ interacting commits for a feature. 
Accordingly, the results of \textsc{bzip2} differ significantly from those of the other projects. 
It was important for us to describe this fact accordingly so that we can justifiably attribute less weight to the results of \textsc{bzip2}.  
It is worth mentioning that the Git development of the other three projects also began with a pre-existing version.  
However, their features were not or only partially implemented at that point.
Their entire code has also changed significantly since then, as can be deducted from the high number of active commits.
We do therefore not consider this circumstance as a major threat to the validity of the results for \textsc{xz}, \textsc{gzip} and \textsc{lrzip}. 
